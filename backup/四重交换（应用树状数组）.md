### 题目大意：

> 给定一个长度为`n`的全排列数组，可以进行的操作是：选定位置`i`，`swap(a[i], a[i + 2]);swap(a[i + 1], a[i + 3]);`要求经过一定的操作以后输出字典序最小的数组

### 解析：

1. 由于交换是隔一位进行交换，所以无论怎么交换奇偶性都不变，因此考虑对奇偶位置的元素进行分开处理
2. 要获得字典序最小的数组需要小的尽量在最前边，要保证四位进行一次交换，就把当前位置换成索引奇偶性相同的依次递增的元素（索引越小元素就选择小），不用考虑操作的次数，因此依次对每一位都进行操作，依次确定了每一位的符合条件的最小的数。但要考虑后三位无法继续通过相同的手法进行处理的元素。
3. 因为数组为全排列，没有重复的元素，`n - 3`号元素已经放了该放的元素，那么`n - 1`号元素也是符合规律的（符合当前项奇偶性相同的所有索引的递增的规律），那么问题从考虑最后三位缩减到了考虑`n`位和考虑`n - 2`位两个元素。
4. 对于这两个元素是否也符合递增的规律，考虑奇偶索引相应元素的替换是同时进行的，而且影响两者关系的只有交换次数的奇偶性，比如奇数索引交换`n`次，偶数索引交换`n - 2`次，这时偶数索引完全可以多交换两次依然递增。但假如两者相差不是偶数，即交换次数的奇偶性是不同的，必然有一方的递增顺序无法实现，这就是前面所说的“考虑`n`位和考虑`n - 2`位两个元素”要考虑的东西，那么答案就按照奇偶性排好然后将这两位替换一下就好了。
5. 在代码实现上的问题：

    * 使用树状数组记录“逆序对数”（**实际就是要交换的次数**）

### 自我思路的桎梏：

1. 没有考虑到对数组进行从头开始的逐步操作，认为这种操作复杂度会很高而错失了后续可以进行构造的思路的可能

### 分治思想的体现:

* 奇偶分开进行排序和一系列操作进行求解

### 代码中出现的问题：

1. 数组越界，对于每一此进行的数组操作进行限制的限制数是否都已经确定了确实是当前数组的长度
2. 逻辑性，如奇偶性及其意义是否都完全对应

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
const long long maxn = 1e6 + 10;
int fen[maxn];
/**
 * 使用树状数组存储数组的逆序对数
 */

//记录频率，因此val就是树状数组中要修改的位置
void update(int x) {
    while(x <= n) {
        fen[x]++;//频率增加
        x += x & -x;//导航父节点
    }
}

//查询前缀和，即比当前元素小的元素数量，以此来记录
int query(int x) {
    int counts = 0;
    while(x) {
        counts += fen[x];
        x -= x & -x;
    }
    return counts;
}

//统计数组中的逆序对数
int f(vector<int> a) {
    //初始化树状数组
    for(int i = 0; i <= n; i++) {
        fen[i] = 0;
    }
    int counts = 0;
    for(int i = a.size() - 1; i >= 0; i--) {
        counts += query(a[i]);
        update(a[i]);
    }
    return counts;
}

void solution() {
    cin >> n;
    vector<int> a(n);
    vector<int> a1, a2;
    for(int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        //方便以后对奇偶索引对应的数进行分别处理
        if(i & 1) {
            a1.push_back(x);
        } else {
            a2.push_back(x);
        }
    }
    //记录奇偶性是否相同
    bool v = ((f(a1) & 1) != (f(a2) & 1));
    sort(a1.begin(), a1.end());
    sort(a2.begin(), a2.end());

    //记录答案
    int i1 = 0, i2 = 0;
    for(int i = 0; i < n; i++) {
        if(i & 1) {
            a[i] = a2[i1++];
        } else {
            a[i] = a1[i2++];
        }
    }

    if(v) {
        swap(a[n - 1], a[n - 3]);
    }
    
    for(int i = 0; i < n; i++) {
        cout << a[i] << " \n"[i == n- 1];
    }
}

int main() {
    ios::sync_with_stdio(0) ; cin.tie(0);
    int t;
    cin >> t;
    while(t--) solution();
    return 0;
}
```

## 使用树状数组（Binary Indexed Tree, BIT）计算数组逆序对数量

> 逆序对是指数组中满足 `i < j` 但 `x[i] > x[j]` 的数对 `(i, j)`。

### 核心思路

1. **树状数组**：树状数组 `fen` 用于高效统计当前元素之前出现过的**元素频率** **。**
2. **逆序遍历**：从数组末尾向前遍历，每次查询当前元素的前缀和（即小于等于当前元素的数量），并将当前元素加入树状数组。
3. **逆序对计算**：对于每个元素 `x[i]`，其逆序对数量为当前已处理元素中大于 `x[i]` 的元素数量，即 `i - que(x[i])`。

### 代码解析

> **定义：** `per`为`for`正循环，`rep`为`for`逆循环，循环变量为`i`，结束条件取`=`

```c++
// 树状数组更新：将位置x的值加1
void upd(int x){
    while(x <= n){
        fen[x]++;
        x += x&-x;
    }
}

// 树状数组查询：返回前缀和（1到x的元素数量）
int que(int x){
    int ans =0 ;
    while(x){
        ans += fen[x] ;
        x -= x&-x;
    }
    return ans ; 
}

// 计算数组x中的逆序对数量
int f(vector<int> x){
    rep(i , 0, n) fen[i] =0; // 初始化树状数组
    int ans =0 ;
    per(i , sz(x)-1 , 0){ // 从后向前遍历数组
        ans += que(x[i]); // 当前元素的逆序对数量
        upd(x[i]) ;       // 将当前元素加入树状数组
    }
    return ans ; 
}
```

