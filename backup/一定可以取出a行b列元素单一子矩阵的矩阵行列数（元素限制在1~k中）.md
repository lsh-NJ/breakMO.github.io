# [[2120D — Matrix Game](https://codeforces.com/contest/2120/problem/D)](https://codeforces.com/contest/2120/problem/D)

 关键词：#84 鸽笼原理，#85 组合，元组，模运算的组合数，乘法逆元，费马小定理，#86 快速幂算法

## 思路：

- ### 先考虑**在一列中的重复现象：**

  数字为1~k，共有n个位置。可看作k个鸽笼，n个鸽子。要有a个重复的元素，每列大小 $n = k(a-1) + 1$即是**最小的行数**

  > 推导：重复的数 a = $\lceil\frac{n}{k}\rceil$（向上取整），根据定义为  $a-1<\frac{n}{k}\le a$，要取n的最小值，$n>k(a-1)$，k、a都是整数，因此加一
  >

  接下来计算**最小的列数**，要保证每行有b个重复元素，列数 m 需满足：$m = (b-1)k \times \binom{n}{a} + 1$即当列数超过 $(b-1)$ 倍种类数时，必存在 b 个相同元组，对应 $a \times b$ 同值子矩阵。

  > 推导：这里也是鸽笼原理，b = $\lceil\frac{m}{K}\rceil$，这里的K情况较为复杂，在推导行数时使用的k是元素的种类数，这里就<u>需要考虑的是元组的种类数</u>。元组的v有k种，对于k种v又有$C_n^a$种组合（组合与顺序无关，因为这里的种类只关心“选哪a行”，显然1，1等同于1，1是第一个1是第一还是第二个1是第一没有意义）。那么 $K=k\cdot C_n^a$
  >
  > - **🔺什么是元组**：(v,p1,p2,…,pa)
  >
  >   其中：
  >
  >   - $v$：元素的具体值（比如数字、符号等，总共有 $k$ 种可能）；
  >   - $p_1, p_2, \dots, p_a$：这 $a$ 个数字是**行号**，且满足 $p_1 < p_2 < \dots < p_a$（按从小到大排列，确保顺序唯一），表示在该列中，值为 $v$ 的元素恰好出现在这些行中。
  >
  >   陈述的是v元素的a次重复位置。
  >