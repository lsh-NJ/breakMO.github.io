## 题目大意：

> 一个二进制字符串，每打印一次记为一次操作，切换打印零还是一也算一次操作，其实位置为0不需要进行切换，要求对字符串进行最多一次字串的反转，得到操作数最小的新字符串

## 思路：

1. 显然操作数 = 字符串长度 + 切换次数 + 1（如果起始位置为‘1’）
2. 所有的字符都可以在最前方加字符0，以实现所有字符串计算的一视同仁
3. 对字符串进行翻转时可以减少操作数，**其原理是**改变前后的“切换关系”，不需要切换，就少一次，那么最多少两次操作
4. 思考这里的两次操作是否通用，即继续思考原理：

    1. 当切换次数达到三次及以上时一定能减少两次操作，因为这时一定能保证找到一个字串使其前后交换以后前后都减少一次操作次数
    2. 切换次数为2时可以减少一次
    3. 切换次数小于等于1次不能减少

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
void testCase() {
    string s;
    int n;
    cin >> n;
    cin >> s;
    s="0"+s;
    int ans = 0, cur = s[0];
    for (int i = 1; i <= n; i++) {
        int dig = s[i];
        if (cur != dig) 
           ans++;
        cur = dig;
    }
   if(ans>=3)
     cout<< ans-2 + n<<"\n";
   else if(ans==2)
     cout<< ans-1 + n<<"\n";
   else 
     cout<<ans+n<<"\n";
}
int main(){
    int t;
    cin>>t;
    while(t--)
        testCase();
    return 0;
}
```