# [[1978C - Manhattan Permutations](https://codeforces.com/problemset/problem/1978/C)](https://codeforces.com/problemset/problem/1978/C)

- `iota`的使用：

  `iota(p.begin(), p.end(), 0);` 是 C++ 标准库中 `<numeric>` 头文件里 `iota` 函数的典型用法，作用是**对容器中元素进行递增初始化**。

  - 前两个参数 `p.begin()` 和 `p.end()` 指定了操作的范围（容器 `p` 的迭代器区间）；
  - 第三个参数 `0` 是初始值，函数会从这个值开始，依次给容器的每个元素赋值，并**自动递增**（每次 +1）。

  例如，若 `p` 是一个包含 5 个元素的 vector，执行后元素会变为 `0, 1, 2, 3, 4`。

# 思路：

- #### 有两重障碍：

  1. 大体构造：了解2*（n-1) ~0之间的所有偶数都可以构造，当k>=2(n - 1)将k消耗掉这一部分，交换1与n，之后检查2与n-1即是k>=2(n-3)
  2. 细致构造：显然有些数并不可通过以上步骤直接构造出来，当k小于当前位置的数时更可以直接构造出来，如1 2 3，12交换为2，13交换为4，直接将当前位置和后移k/2的数直接交换就可以了。

      这样构造是必要的，因为显然大体构造中层与层之间有一个数漏了过去，如果不直接构造将其一次性清楚很可能在最内层发生重复交换，但是重复交换不改变排列的曼哈顿值。