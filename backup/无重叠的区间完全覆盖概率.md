[[D - Segments Covering](https://codeforces.com/contest/2125/problem/D)](https://codeforces.com/contest/2125/problem/D)

## 思路：

- 维护一个dp，下标表示1-i区间被完全覆盖且无重叠的概率
- 递推：

  1. 由前一个区间推出，考虑会重叠的概率
  2. 有两种重叠，右端点在该区间范围内的重叠，右端点在该区间右侧的重叠。每次只计算第一种重叠，第二种交由以后的区间计算。
  3. 相同的1-i被完全覆盖要用加法。

## 概率论中的算法：

1. 加法计算“不发生的概率”以及**<u>互斥事件至少有一个发生的概率</u>**
2. 乘法简化快速幂以及**<u>独立事件同时发生的概率</u>**
3. 除法计算模环境下的分数
4. 快速幂计算乘法逆元

```cpp
const int mod = 998244353;
int add(int x, int y) {
  return (x + y + mod) % mod;
}

int mul(int x, int y) {
  return x * y % mod;
}

int fast_pow(int x, int y) {
  int res = 1;
  while(y) {
    if(y & 1) res = mul(res, x);
    x = mul(x, x);
    y >>= 1;
  }
  return res;
}

int divide(int x, int y) {
  return mul(x, fast_pow(y, mod - 2));
}
```