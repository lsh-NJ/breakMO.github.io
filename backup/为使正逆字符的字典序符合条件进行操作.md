## 问题：

* **定义一种特殊的字符串正序字典序小于逆序字符串的字典序，现在给定一个字符串（长度为n， 只包含小写字符），在给定一个操作次数k，进行如下操作：**

  * 选定i，j两个坐标进行字符反转，如果两者相等就不进行任何操作

  **问：经过k次操作后该字符串能否变成特殊的字符串？**

## 思路：

* ### 进行分类讨论：

  1. 简单的，字符长度为1肯定是“NO”
  2. 给定的字符串有可能直接就是符合条件的特殊字符串
  3. 对给定的字符串进行操作：

      1. 对于非回文字符串，若不符合条件交换正序与逆序第一个不同的字符串就可以符合条件了（😭我眼泪怎么止不住了？）
      2. 对于回文字符串（旨在解决上一个操作无法解决的问题，也就是说先想到了解决方法，然后找到了特解进行修补？不确定），如果不符合条件，就把相邻的两个不同的字符交换就可以了
  4. **综上所述：直接判原字符串是否符合条件秒杀1、2类，检查最大最小值是否相同就秒杀了3类（第三类实质上都是对不同字符的一次操作解决的）**

## 反思：🚩

* 作为一道甚至说是“简单”级别的构造题，我做了很久，至少一个半小时。我快速查看题解，还理解错了题解的含义……就是懒病犯了，半场开香槟了。看题解当然不能是一个放松的过程，需要认真思考思路和实现代码是怎么样的。
* 还有就是基础问题，字符串字典序比较的过程，字符串最后一位是长度-1这么基础的问题竟然不知道多少次没有注意了？
* 字符串逆序用reserve
* string类型可以直接比较字典序

## 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;

void solution() {
    int n, k;
    string s;
    cin >> n >> k >> s;
    char Min = 'z', Max = 'a';
    for(int i = 0; i < s.length(); i++) {
        if(s[i] < Min) Min = s[i];
        if(s[i] > Max) Max = s[i];
    }

    string rev = s;
    reverse(s.begin(), s.end());
    if(s > rev || (Max != Min && k >= 1))
        cout << "YES" << endl;
    else 
        cout << "NO" << endl;
}

int main() {
    int t; 
    cin >> t;
    while(t--) solution();
    return 0;
}
```