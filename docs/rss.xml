<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Break_M</title><link>https://lsh-NJ.github.io/breakMO.github.io</link><description>你想度过，怎么样的一生？</description><copyright>Break_M</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://tse4.mm.bing.net/th/id/OIP.lKmqCoEUSaq-GtTpYi8s3wHaEd?cb=iwp1&amp;rs=1&amp;pid=ImgDetMain</url><title>avatar</title><link>https://lsh-NJ.github.io/breakMO.github.io</link></image><lastBuildDate>Thu, 15 May 2025 06:12:18 +0000</lastBuildDate><managingEditor>Break_M</managingEditor><ttl>60</ttl><webMaster>Break_M</webMaster><item><title>四重交换（应用树状数组）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/si-zhong-jiao-huan-%EF%BC%88-ying-yong-shu-zhuang-shu-zu-%EF%BC%89.html</link><description>### 题目大意：

&gt; 给定一个长度为`n`的全排列数组，可以进行的操作是：选定位置`i`，`swap(a[i], a[i + 2]);swap(a[i + 1], a[i + 3]);`要求经过一定的操作以后输出字典序最小的数组

### 解析：

1. 由于交换是隔一位进行交换，所以无论怎么交换奇偶性都不变，因此考虑对奇偶位置的元素进行分开处理
2. 要获得字典序最小的数组需要小的尽量在最前边，要保证四位进行一次交换，就把当前位置换成索引奇偶性相同的依次递增的元素（索引越小元素就选择小），不用考虑操作的次数，因此依次对每一位都进行操作，依次确定了每一位的符合条件的最小的数。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/si-zhong-jiao-huan-%EF%BC%88-ying-yong-shu-zhuang-shu-zu-%EF%BC%89.html</guid><pubDate>Wed, 14 May 2025 13:31:50 +0000</pubDate></item><item><title>树状数组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zhuang-shu-zu.html</link><description>**树状数组**（Binary Indexed Tree，BIT），也被叫做 Fenwick Tree，是一种能够**高效处理区间查询与单点更新问题的数据结构**。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zhuang-shu-zu.html</guid><pubDate>Wed, 14 May 2025 08:58:35 +0000</pubDate></item><item><title>操作符重载</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/cao-zuo-fu-zhong-zai.html</link><description>&lt;html&gt;
&lt;body&gt;
&lt;!--StartFragment--&gt;&lt;p id='20250512165959-3vsjxig' updated='20250512165959'&gt;在C++中，操作符重载允许你为自定义类型重新定义运算符的行为，使得这些运算符可以用于自定义类型的对象。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/cao-zuo-fu-zhong-zai.html</guid><pubDate>Tue, 13 May 2025 16:33:39 +0000</pubDate></item><item><title>SPFA（Bellman_ford队列优化）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/SPFA%EF%BC%88Bellman_ford-dui-lie-you-hua-%EF%BC%89.html</link><description>## 解析：

1. 相对于普通版优化掉了被`if(!minDist[start])`排除的无效松弛

    * 通过队列存储可以对周围进行有效松弛的点
2. 为什么队列中不能同时存在一个点但是队列中可以多次存在一个点？

    * 有可能先接触到的点的最短距离还可以进行松弛，那么之后的点位都需要继续进行松弛，通过队列的形式也恰巧可以再次发散松弛后续节点并排除已松弛到最佳的节点

## 注意：

* `queue`容器要使用`front()`
* `top()`函数用于`stack`\\`priority_queue`容器
* 依然对每个遍历到的点都要进行`minDist`最短距离的刷新
* 只在队列是否要插入点时判断点是否已经在队列中

## 优化 检查负权回路：

* 记录点进入队列的次数就相当于记录了松弛的次数

## 代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int n, m, s, e, val;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; grid(n + 1);
    for(int i = 0; i &lt; m; i++) {
        cin &gt;&gt; s &gt;&gt; e &gt;&gt; val;
        grid[s].push_back({e, val});
    }
    
    vector&lt;int&gt; minDist(n + 1, INT_MAX);
    vector&lt;int&gt; inQueue(n + 1, false);//记录已经在队列中的元素
    minDist[1] = 0;
    queue&lt;int&gt; q;
    q.push(1);
    inQueue[1] = true;
    vector&lt;int&gt; count(n + 1, 0);//记录节点加入队列的次数
    bool flag = false;//记录是否存在负权回路
    
    while (!q.empty())
    {
        int cur = q.front();
        q.pop();
        inQueue[cur] = false;
        for(pair&lt;int, int&gt; edge:grid[cur]) {
            int to = edge.first;
            int val = edge.second;
            if(val + minDist[cur] &lt; minDist[to]) {
                minDist[to] = val + minDist[cur];
                //已经在队列中不用重复添加
                if(!inQueue[to]) {
                    inQueue[to] = true;
                    q.push(to);
                    count[to]++;
                    if(count[to] == n) {//松弛超过n - 1次
                        flag = true;
                        while(!q.empty()) q.pop();
                        break;
                    }
                }
            }
        }
    }
    
    if(flag) cout &lt;&lt; 'circle' &lt;&lt; endl;
    else
        minDist[n] == INT_MAX? cout &lt;&lt; 'unconnected' &lt;&lt; endl: cout &lt;&lt; minDist[n] &lt;&lt; endl;
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/SPFA%EF%BC%88Bellman_ford-dui-lie-you-hua-%EF%BC%89.html</guid><pubDate>Tue, 13 May 2025 16:30:33 +0000</pubDate></item><item><title>prim（记录树）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/prim%EF%BC%88-ji-lu-shu-%EF%BC%89.html</link><description>## prim三部曲：

1. 选择距离生成树最近的节点
2. 把最近节点加入生成树
3. 更新非生成树节点到生成树的距离

&gt; 使用一维数组存储最小生成树

## 记录树的细节分析：

* 树的特点是入度为1，所以记录父节点不会出现链接关系被覆盖的情况

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() {
    int n, m, s, e, val;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; graph(n + 1, vector&lt;int&gt;(n + 1, INT_MAX));
    //记录树+
    vector&lt;int&gt; parent(n + 1, -1);
    for(int i = 0; i &lt; m; i++) {
        cin &gt;&gt; s &gt;&gt; e &gt;&gt; val;
        graph[s][e] = val;
        graph[e][s] = val;
    }

    vector&lt;bool&gt; visted(n + 1, false);
    vector&lt;int&gt; miniDist(n + 1, INT_MAX);
    miniDist[1] = 0;

    for(int i = 0; i &lt; n; i++) {
        int cur = 0;
        //寻找最近距离的点
        for(int j = 1; j &lt;= n; j++) {
            if(!visted[j] &amp;&amp; miniDist[j] &lt; miniDist[cur]) {
                cur = j;
            }
        }
        //将该标记为visited
        visted[cur] = true;
        //更新miniDist数组
        for(int j = 1; j &lt;= n; j++) {
            if(!visted[j] &amp;&amp; miniDist[j] &gt; graph[cur][j]) {
                miniDist[j] = graph[cur][j];
                //记录点的连接关系+
                parent[j] = cur;
            }
        }
    }
    //输出 最小生成树
    int res = 0;
    for(int i = 1; i &lt;= n; i++) {
        res += miniDist[i];
    }
    cout &lt;&lt; res &lt;&lt; endl;

    // 输出 最小生成树边的链接情况
    for (int i = 1; i &lt;= v; i++) {
        cout &lt;&lt; i &lt;&lt; '-&gt;' &lt;&lt; parent[i] &lt;&lt; endl;
    }
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/prim%EF%BC%88-ji-lu-shu-%EF%BC%89.html</guid><pubDate>Tue, 13 May 2025 15:30:16 +0000</pubDate></item><item><title>Bellman_ford</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/Bellman_ford.html</link><description>&gt; 思路特别像prim

## 过程：

* 对`m`条边进行`n - 1`（点数-1）次松弛，更新每个点到原点的最短距离`minDist[to] = min(minDist[to], minDist[start] + val);`
* 理论上，i次松弛使相应节点有距离i条边的最短距离（有也就是说大于i次松弛可能会找到距离边数更多但更短的距离）

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int n, m, s, e, val;
    cin &gt;&gt; n &gt;&gt; m;

	//用来存放边与其权值的数组
    vector&lt;vector&lt;int&gt;&gt; grid;
    for(int i = 0; i &lt; m; i++) {
        cin &gt;&gt; s &gt;&gt; e &gt;&gt; val;
        grid.push_back({s, e, val});
    }

	//存放距离原点的最短总距离
    vector&lt;int&gt; minDist(n + 1, INT_MAX);
    minDist[1] = 0;

    //n - 1次松弛
    for(int i = 0; i &lt; n - 1; i++) {
        //对每一条边进行松弛
        for(int j = 0; j &lt; m; j++) {
            int start = grid[j][0];
            int to = grid[j][1];
            int val = grid[j][2];
			//松弛的过程
            if(minDist[start] != INT_MAX &amp;&amp; minDist[start] + val &lt; minDist[to]) {
                minDist[to] = minDist[start] + val;
            }
        }
    }

    minDist[n] == INT_MAX? cout &lt;&lt; 'unconnected' &lt;&lt; endl: cout &lt;&lt; minDist[n] &lt;&lt; endl;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/Bellman_ford.html</guid><pubDate>Tue, 13 May 2025 15:03:59 +0000</pubDate></item><item><title>函数对象（仿函数）以及函数模板与类模板</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/han-shu-dui-xiang-%EF%BC%88-fang-han-shu-%EF%BC%89-yi-ji-han-shu-mo-ban-yu-lei-mo-ban.html</link><description>## 函数模板与类模板

### 一、关键区别：（举例）

#### 1. **`sort`** **是函数模板**

cpp

```cpp
template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );
```

* **lambda 可以隐式转换为函数参数**：
  函数调用时，lambda 会被推导为具体的匿名类型，作为`comp`参数传递给`sort`。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/han-shu-dui-xiang-%EF%BC%88-fang-han-shu-%EF%BC%89-yi-ji-han-shu-mo-ban-yu-lei-mo-ban.html</guid><pubDate>Mon, 12 May 2025 04:10:13 +0000</pubDate></item><item><title>2025/5/11周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-11-zhou-ji.html</link><description>一切都是缘分吗？所谓命运的馈赠。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-11-zhou-ji.html</guid><pubDate>Sun, 11 May 2025 08:17:23 +0000</pubDate></item><item><title>C++的Lambda表达式（隐函数）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/C%2B%2B-de-Lambda-biao-da-shi-%EF%BC%88-yin-han-shu-%EF%BC%89.html</link><description>1. #### 基本结构：

    `[capture](parameters) -&gt; return_type { body }`

    * **`[capture]`** ：捕获列表，用于指定如何捕获外部变量（值捕获、引用捕获等）。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/C%2B%2B-de-Lambda-biao-da-shi-%EF%BC%88-yin-han-shu-%EF%BC%89.html</guid><pubDate>Sat, 10 May 2025 11:26:39 +0000</pubDate></item><item><title>dijkstra（堆优化版）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-dui-you-hua-ban-%EF%BC%89.html</link><description>## 图的表示方式：

1. ### 邻接矩阵

    * #### 优点：

      * 检查任意两个顶点间是否存在边的操作非常快
      * 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-dui-you-hua-ban-%EF%BC%89.html</guid><pubDate>Fri, 09 May 2025 01:26:38 +0000</pubDate></item><item><title>最大子数组和及其构造变式（有趣）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zui-da-zi-shu-zu-he-ji-qi-gou-zao-bian-shi-%EF%BC%88-you-qu-%EF%BC%89.html</link><description>## 复习最大数组和：

1. ### 贪心做法：

    * #### 思路：

      &gt; 遍历的过程中不断维护一个区间和，如果区间和小于零就到达该区间的结束，使和变为0即重新维护一个新的区间，在维护的过程中不断检查区间和的最大值，这样就可以得到最大的那个区间的区间和。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zui-da-zi-shu-zu-he-ji-qi-gou-zao-bian-shi-%EF%BC%88-you-qu-%EF%BC%89.html</guid><pubDate>Thu, 08 May 2025 10:14:34 +0000</pubDate></item><item><title>证伪偶数全排列无法实现ai mod i = i - 1</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zheng-wei-ou-shu-quan-pai-lie-wu-fa-shi-xian-ai%20mod%20i%20%3D%20i%20-%201.html</link><description>## 题目大意：

&gt; 给定1~n个数，要求对其进行重新排列为数组a满足`a[i] % i = i - 1`

## 证明n为偶数不可能有满足条件的数组：

* 设最大的偶数为n，n不能放在`a[n]` `a[1]` `a[2]`处（思路：通过假设试图寻找通式，奇偶性肯定是要讨论的问题，然后通过左右边界来探索问题）
* n只能放在3~n-1处，那么不能放n的位置就要放两个偶数，显然2是偶数，n也是偶数，偶数与偶数的余不可能是奇数，不符合条件。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zheng-wei-ou-shu-quan-pai-lie-wu-fa-shi-xian-ai%20mod%20i%20%3D%20i%20-%201.html</guid><pubDate>Wed, 07 May 2025 08:18:11 +0000</pubDate></item><item><title>一种有趣的答案输出格式化代码</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/yi-zhong-you-qu-de-da-an-shu-chu-ge-shi-hua-dai-ma.html</link><description>## 代码：

```cpp
for(int i = 0; i &lt; n; i++) {
	cout &lt;&lt; '输出内容' &lt;&lt; ' \n'[i == n - 1];
}
```

* 使用了c++的数组（字符串）特性，不是最后一位就用空格隔开，是最后一位就换行。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/yi-zhong-you-qu-de-da-an-shu-chu-ge-shi-hua-dai-ma.html</guid><pubDate>Wed, 07 May 2025 08:03:42 +0000</pubDate></item><item><title>数组最大公约数分组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-zui-da-gong-yue-shu-fen-zu.html</link><description>## 题目大意：

&gt; 给定一个数组，要求将其分成两组最大公约数不同的子数组，若可以实现，输出“YES”，并输出每一个元素属于第几组，不可以实现只输出“NO”即可

## 解析:

1. 只要最大的数自己一组，最大公约数就是自己（可以从样例中看出）
2. 由1得，只要所有的数不重复就可以满足条件。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-zui-da-gong-yue-shu-fen-zu.html</guid><pubDate>Wed, 07 May 2025 02:18:12 +0000</pubDate></item><item><title>数组博弈</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-bo-yi.html</link><description>## 题目大意：

&gt; n盒子，ai苹果，两人分别取苹果，苹果总数为0没办法再取出当前人就输，如果最大值和最小值差值大于k那么当前人就输（**最后一个取苹果的人**）

## 解析：

* 显然两个足够聪明的人不会使最大值和最小值的差值越界，那么这个约束条件只在开始产生效果，这样就有如下情况：

  1. 刚开始最大值和最小值的差值不满足条件，题目要求输的是最后一个取苹果的人，所以不满足条件第一个人也要去取一个苹果，又有以下情况：

      1. 取一个依然不满足条件，第一个人失败
      2. 取一个满足条件，正常进行后续取出苹果
  2. 正常情况：看总数奇偶性就可以了

## 优化代码：

1. 处理过程中有多个max可以考虑**使用**两次**&lt;u&gt;sort&lt;/u&gt;**，sort也可以代替寻找最大最小值的过程

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int t; cin &gt;&gt; t;
    
    while (t--){
        int n, k; cin &gt;&gt; n &gt;&gt; k;
        
        vector &lt;int&gt; a(n);
        for (auto &amp;x : a) cin &gt;&gt; x;
        
        long long sum = accumulate(a.begin(), a.end(), 0LL);
        
        sort(a.begin(), a.end());
        a[n - 1]--;
        sort(a.begin(), a.end());
        
        if (a[n - 1] - a[0] &gt; k || sum % 2 == 0){
            cout &lt;&lt; 'Jerry\n';
            continue;
        }
        cout &lt;&lt; 'Tom\n';
    }
    return 0;
}
```

## 我的代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
 
void solution() {
    string win[] = {'Tom', 'Jerry'};
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;int&gt; a(n, 0);
    int Max = 0, Min = 1e9 + 5, maxCounts = 0;
    long long sum = 0;

    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
        // Max = max(Max, a[i]);
        if(a[i] &gt; Max) {
            Max = a[i];
            maxCounts = 1;
        } else if(a[i] == Max) maxCounts++;
        Min = min(Min, a[i]);
        sum += a[i];
    }

    if((Max - Min ==  k + 1 &amp;&amp; maxCounts &gt; 1) || Max - Min &gt; k + 1) {
        cout &lt;&lt; win[1] &lt;&lt; endl;
        return;
    }

    //直接通过sum奇偶性判断输家
    if(sum &amp; 1) cout &lt;&lt; win[0] &lt;&lt; endl;
    else cout &lt;&lt; win[1] &lt;&lt; endl;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while(t--) solution();
    return 0;
}

```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-bo-yi.html</guid><pubDate>Tue, 06 May 2025 13:39:11 +0000</pubDate></item><item><title>为使正逆字符的字典序符合条件进行操作</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/wei-shi-zheng-ni-zi-fu-de-zi-dian-xu-fu-he-tiao-jian-jin-xing-cao-zuo.html</link><description>## 问题：

* **定义一种特殊的字符串正序字典序小于逆序字符串的字典序，现在给定一个字符串（长度为n， 只包含小写字符），在给定一个操作次数k，进行如下操作：**

  * 选定i，j两个坐标进行字符反转，如果两者相等就不进行任何操作

  **问：经过k次操作后该字符串能否变成特殊的字符串？**

## 思路：

* ### 进行分类讨论：

  1. 简单的，字符长度为1肯定是“NO”
  2. 给定的字符串有可能直接就是符合条件的特殊字符串
  3. 对给定的字符串进行操作：

      1. 对于非回文字符串，若不符合条件交换正序与逆序第一个不同的字符串就可以符合条件了（😭我眼泪怎么止不住了？）
      2. 对于回文字符串（旨在解决上一个操作无法解决的问题，也就是说先想到了解决方法，然后找到了特解进行修补？不确定），如果不符合条件，就把相邻的两个不同的字符交换就可以了
  4. **综上所述：直接判原字符串是否符合条件秒杀1、2类，检查最大最小值是否相同就秒杀了3类（第三类实质上都是对不同字符的一次操作解决的）**

## 反思：🚩

* 作为一道甚至说是“简单”级别的构造题，我做了很久，至少一个半小时。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/wei-shi-zheng-ni-zi-fu-de-zi-dian-xu-fu-he-tiao-jian-jin-xing-cao-zuo.html</guid><pubDate>Mon, 05 May 2025 13:08:56 +0000</pubDate></item><item><title>循环移位操作下排列中固定点的问题（真的吃力😓）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/xun-huan-yi-wei-cao-zuo-xia-pai-lie-zhong-gu-ding-dian-de-wen-ti-%EF%BC%88-zhen-de-chi-li-%F0%9F%98%93%EF%BC%89.html</link><description>## 模运算：

* ### 定义

  a除以b的余数定义为a mod b

  满足交换律、结合律还有分配律

## 排列与组合

* ### 排列：

  从n个不同元素中取出 m（m &lt;= n）个元素，**&lt;u&gt;按照一定的顺序排成一列&lt;/u&gt;**，叫做从n个不同元素中取出m个元素的一个排列。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/xun-huan-yi-wei-cao-zuo-xia-pai-lie-zhong-gu-ding-dian-de-wen-ti-%EF%BC%88-zhen-de-chi-li-%F0%9F%98%93%EF%BC%89.html</guid><pubDate>Mon, 05 May 2025 09:19:45 +0000</pubDate></item><item><title>再观补码与数据极限</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zai-guan-bu-ma-yu-shu-ju-ji-xian.html</link><description>## 求补码的方法：

* **正数**：正数的原码、反码和补码都相同，符号位始终为 0 不变。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zai-guan-bu-ma-yu-shu-ju-ji-xian.html</guid><pubDate>Mon, 05 May 2025 02:06:36 +0000</pubDate></item><item><title>2025/5/4周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-4-zhou-ji.html</link><description>周日这天搭建了自己的博客，希望有一天可以自己为博客写一个UI系统，自己的设计也太酷了吧！

**算法**还是有点有基础不牢地动山摇了，我觉得之后要一点一点好好**从基础学起**了

还有**算法题**。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-4-zhou-ji.html</guid><pubDate>Sun, 04 May 2025 14:19:16 +0000</pubDate></item><item><title>环状数组（双数组模拟环）（字典序）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/huan-zhuang-shu-zu-%EF%BC%88-shuang-shu-zu-mo-ni-huan-%EF%BC%89%EF%BC%88-zi-dian-xu-%EF%BC%89.html</link><description>![Image](https://github.com/user-attachments/assets/c0cd669f-ab49-4b72-803a-478161e4b9c1)

&gt; 所谓字典序，就是字符串在字典中的顺序。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/huan-zhuang-shu-zu-%EF%BC%88-shuang-shu-zu-mo-ni-huan-%EF%BC%89%EF%BC%88-zi-dian-xu-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 09:16:52 +0000</pubDate></item><item><title>生成元（使用哈希表提高大量数据的处理效率）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/sheng-cheng-yuan-%EF%BC%88-shi-yong-ha-xi-biao-ti-gao-da-liang-shu-ju-de-chu-li-xiao-lv-%EF%BC%89.html</link><description>### 问题：

&gt; x加x的各个数字得到y，就说x是y的生成元。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/sheng-cheng-yuan-%EF%BC%88-shi-yong-ha-xi-biao-ti-gao-da-liang-shu-ju-de-chu-li-xiao-lv-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 08:06:33 +0000</pubDate></item><item><title>输入string转vector</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-ru-string-zhuan-vector.html</link><description>### C++中读取字符串为`vector&lt;char&gt;`的方法：

```cpp
string input;
getline(cin, input); // cin &gt;&gt; input
vector&lt;char&gt; charVector(input.begin(), input.end());
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-ru-string-zhuan-vector.html</guid><pubDate>Sun, 04 May 2025 07:32:51 +0000</pubDate></item><item><title>回文与镜像（字符串的灵活使用）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/hui-wen-yu-jing-xiang-%EF%BC%88-zi-fu-chuan-de-ling-huo-shi-yong-%EF%BC%89.html</link><description>![Image](https://github.com/user-attachments/assets/d7cc37ad-718d-4f77-b57a-9d5cc47ae942){style='width:50%;'}

* 镜像可以用一个字符串`rev`表示出来，做镜像就可以直接取字母序号对应的字符来进行替换。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/hui-wen-yu-jing-xiang-%EF%BC%88-zi-fu-chuan-de-ling-huo-shi-yong-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 07:25:36 +0000</pubDate></item><item><title>dijkstra（朴素版）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-pu-su-ban-%EF%BC%89.html</link><description>&gt; `dijkstra`在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-pu-su-ban-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 04:50:57 +0000</pubDate></item></channel></rss>