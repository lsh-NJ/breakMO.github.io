<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Break_M</title><link>https://lsh-NJ.github.io/breakMO.github.io</link><description>你想度过，怎么样的一生？</description><copyright>Break_M</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://tse4.mm.bing.net/th/id/OIP.lKmqCoEUSaq-GtTpYi8s3wHaEd?rs=1&amp;pid=ImgDetMain</url><title>avatar</title><link>https://lsh-NJ.github.io/breakMO.github.io</link></image><lastBuildDate>Mon, 05 May 2025 13:09:21 +0000</lastBuildDate><managingEditor>Break_M</managingEditor><ttl>60</ttl><webMaster>Break_M</webMaster><item><title>为使正逆字符的字典序符合条件进行操作</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/wei-shi-zheng-ni-zi-fu-de-zi-dian-xu-fu-he-tiao-jian-jin-xing-cao-zuo.html</link><description>## 问题：

* **定义一种特殊的字符串正序字典序小于逆序字符串的字典序，现在给定一个字符串（长度为n， 只包含小写字符），在给定一个操作次数k，进行如下操作：**

  * 选定i，j两个坐标进行字符反转，如果两者相等就不进行任何操作

  **问：经过k次操作后该字符串能否变成特殊的字符串？**

## 思路：

* ### 进行分类讨论：

  1. 简单的，字符长度为1肯定是“NO”
  2. 给定的字符串有可能直接就是符合条件的特殊字符串
  3. 对给定的字符串进行操作：

      1. 对于非回文字符串，若不符合条件交换正序与逆序第一个不同的字符串就可以符合条件了（😭我眼泪怎么止不住了？）
      2. 对于回文字符串（旨在解决上一个操作无法解决的问题，也就是说先想到了解决方法，然后找到了特解进行修补？不确定），如果不符合条件，就把相邻的两个不同的字符交换就可以了
  4. **综上所述：直接判原字符串是否符合条件秒杀1、2类，检查最大最小值是否相同就秒杀了3类（第三类实质上都是对不同字符的一次操作解决的）**

## 反思：🚩

* 作为一道甚至说是“简单”级别的构造题，我做了很久，至少一个半小时。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/wei-shi-zheng-ni-zi-fu-de-zi-dian-xu-fu-he-tiao-jian-jin-xing-cao-zuo.html</guid><pubDate>Mon, 05 May 2025 13:08:56 +0000</pubDate></item><item><title>循环移位操作下排列中固定点的问题（真的吃力😓）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/xun-huan-yi-wei-cao-zuo-xia-pai-lie-zhong-gu-ding-dian-de-wen-ti-%EF%BC%88-zhen-de-chi-li-%F0%9F%98%93%EF%BC%89.html</link><description>## 模运算：

* ### 定义

  a除以b的余数定义为a mod b

  满足交换律、结合律还有分配律

## 排列与组合

* ### 排列：

  从n个不同元素中取出 m（m &lt;= n）个元素，**&lt;u&gt;按照一定的顺序排成一列&lt;/u&gt;**，叫做从n个不同元素中取出m个元素的一个排列。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/xun-huan-yi-wei-cao-zuo-xia-pai-lie-zhong-gu-ding-dian-de-wen-ti-%EF%BC%88-zhen-de-chi-li-%F0%9F%98%93%EF%BC%89.html</guid><pubDate>Mon, 05 May 2025 09:19:45 +0000</pubDate></item><item><title>再观补码与数据极限</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zai-guan-bu-ma-yu-shu-ju-ji-xian.html</link><description>## 求补码的方法：

* **正数**：正数的原码、反码和补码都相同，符号位始终为 0 不变。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zai-guan-bu-ma-yu-shu-ju-ji-xian.html</guid><pubDate>Mon, 05 May 2025 02:06:36 +0000</pubDate></item><item><title>2025/5/4周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-4-zhou-ji.html</link><description>周日这天搭建了自己的博客，希望有一天可以自己为博客写一个UI系统，自己的设计也太酷了吧！

**算法**还是有点有基础不牢地动山摇了，我觉得之后要一点一点好好**从基础学起**了

还有**算法题**。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-4-zhou-ji.html</guid><pubDate>Sun, 04 May 2025 14:19:16 +0000</pubDate></item><item><title>环状数组（双数组模拟环）（字典序）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/huan-zhuang-shu-zu-%EF%BC%88-shuang-shu-zu-mo-ni-huan-%EF%BC%89%EF%BC%88-zi-dian-xu-%EF%BC%89.html</link><description>![Image](https://github.com/user-attachments/assets/c0cd669f-ab49-4b72-803a-478161e4b9c1)

&gt; 所谓字典序，就是字符串在字典中的顺序。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/huan-zhuang-shu-zu-%EF%BC%88-shuang-shu-zu-mo-ni-huan-%EF%BC%89%EF%BC%88-zi-dian-xu-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 09:16:52 +0000</pubDate></item><item><title>生成元（使用哈希表提高大量数据的处理效率）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/sheng-cheng-yuan-%EF%BC%88-shi-yong-ha-xi-biao-ti-gao-da-liang-shu-ju-de-chu-li-xiao-lv-%EF%BC%89.html</link><description>### 问题：

&gt; x加x的各个数字得到y，就说x是y的生成元。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/sheng-cheng-yuan-%EF%BC%88-shi-yong-ha-xi-biao-ti-gao-da-liang-shu-ju-de-chu-li-xiao-lv-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 08:06:33 +0000</pubDate></item><item><title>输入string转vector</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-ru-string-zhuan-vector.html</link><description>### C++中读取字符串为`vector&lt;char&gt;`的方法：

```cpp
string input;
getline(cin, input); // cin &gt;&gt; input
vector&lt;char&gt; charVector(input.begin(), input.end());
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-ru-string-zhuan-vector.html</guid><pubDate>Sun, 04 May 2025 07:32:51 +0000</pubDate></item><item><title>回文与镜像（字符串的灵活使用）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/hui-wen-yu-jing-xiang-%EF%BC%88-zi-fu-chuan-de-ling-huo-shi-yong-%EF%BC%89.html</link><description>![Image](https://github.com/user-attachments/assets/d7cc37ad-718d-4f77-b57a-9d5cc47ae942){style='width:50%;'}

* 镜像可以用一个字符串`rev`表示出来，做镜像就可以直接取字母序号对应的字符来进行替换。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/hui-wen-yu-jing-xiang-%EF%BC%88-zi-fu-chuan-de-ling-huo-shi-yong-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 07:25:36 +0000</pubDate></item><item><title>dijkstra（朴素版）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-pu-su-ban-%EF%BC%89.html</link><description>&gt; `dijkstra`在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-pu-su-ban-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 04:50:57 +0000</pubDate></item></channel></rss>