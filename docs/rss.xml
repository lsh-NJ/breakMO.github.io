<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Break_M</title><link>https://lsh-NJ.github.io/breakMO.github.io</link><description>你想度过，怎么样的一生？</description><copyright>Break_M</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://tse4.mm.bing.net/th/id/OIP.lKmqCoEUSaq-GtTpYi8s3wHaEd?rs=1&amp;pid=ImgDetMain</url><title>avatar</title><link>https://lsh-NJ.github.io/breakMO.github.io</link></image><lastBuildDate>Wed, 07 May 2025 08:18:37 +0000</lastBuildDate><managingEditor>Break_M</managingEditor><ttl>60</ttl><webMaster>Break_M</webMaster><item><title>证伪偶数全排列无法实现ai mod i = i - 1</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zheng-wei-ou-shu-quan-pai-lie-wu-fa-shi-xian-ai%20mod%20i%20%3D%20i%20-%201.html</link><description>## 题目大意：

&gt; 给定1~n个数，要求对其进行重新排列为数组a满足`a[i] % i = i - 1`

## 证明n为偶数不可能有满足条件的数组：

* 设最大的偶数为n，n不能放在`a[n]` `a[1]` `a[2]`处（思路：通过假设试图寻找通式，奇偶性肯定是要讨论的问题，然后通过左右边界来探索问题）
* n只能放在3~n-1处，那么不能放n的位置就要放两个偶数，显然2是偶数，n也是偶数，偶数与偶数的余不可能是奇数，不符合条件。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zheng-wei-ou-shu-quan-pai-lie-wu-fa-shi-xian-ai%20mod%20i%20%3D%20i%20-%201.html</guid><pubDate>Wed, 07 May 2025 08:18:11 +0000</pubDate></item><item><title>一种有趣的答案输出格式化代码</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/yi-zhong-you-qu-de-da-an-shu-chu-ge-shi-hua-dai-ma.html</link><description>## 代码：

```cpp
for(int i = 0; i &lt; n; i++) {
	cout &lt;&lt; '输出内容' &lt;&lt; ' \n'[i == n - 1];
}
```

* 使用了c++的数组（字符串）特性，不是最后一位就用空格隔开，是最后一位就换行。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/yi-zhong-you-qu-de-da-an-shu-chu-ge-shi-hua-dai-ma.html</guid><pubDate>Wed, 07 May 2025 08:03:42 +0000</pubDate></item><item><title>数组最大公约数分组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-zui-da-gong-yue-shu-fen-zu.html</link><description>## 题目大意：

&gt; 给定一个数组，要求将其分成两组最大公约数不同的子数组，若可以实现，输出“YES”，并输出每一个元素属于第几组，不可以实现只输出“NO”即可

## 解析:

1. 只要最大的数自己一组，最大公约数就是自己（可以从样例中看出）
2. 由1得，只要所有的数不重复就可以满足条件。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-zui-da-gong-yue-shu-fen-zu.html</guid><pubDate>Wed, 07 May 2025 02:18:12 +0000</pubDate></item><item><title>数组博弈</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-bo-yi.html</link><description>## 题目大意：

&gt; n盒子，ai苹果，两人分别取苹果，苹果总数为0没办法再取出当前人就输，如果最大值和最小值差值大于k那么当前人就输（**最后一个取苹果的人**）

## 解析：

* 显然两个足够聪明的人不会使最大值和最小值的差值越界，那么这个约束条件只在开始产生效果，这样就有如下情况：

  1. 刚开始最大值和最小值的差值不满足条件，题目要求输的是最后一个取苹果的人，所以不满足条件第一个人也要去取一个苹果，又有以下情况：

      1. 取一个依然不满足条件，第一个人失败
      2. 取一个满足条件，正常进行后续取出苹果
  2. 正常情况：看总数奇偶性就可以了

## 优化代码：

1. 处理过程中有多个max可以考虑**使用**两次**&lt;u&gt;sort&lt;/u&gt;**，sort也可以代替寻找最大最小值的过程

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int t; cin &gt;&gt; t;
    
    while (t--){
        int n, k; cin &gt;&gt; n &gt;&gt; k;
        
        vector &lt;int&gt; a(n);
        for (auto &amp;x : a) cin &gt;&gt; x;
        
        long long sum = accumulate(a.begin(), a.end(), 0LL);
        
        sort(a.begin(), a.end());
        a[n - 1]--;
        sort(a.begin(), a.end());
        
        if (a[n - 1] - a[0] &gt; k || sum % 2 == 0){
            cout &lt;&lt; 'Jerry\n';
            continue;
        }
        cout &lt;&lt; 'Tom\n';
    }
    return 0;
}
```

## 我的代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
 
void solution() {
    string win[] = {'Tom', 'Jerry'};
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;int&gt; a(n, 0);
    int Max = 0, Min = 1e9 + 5, maxCounts = 0;
    long long sum = 0;

    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
        // Max = max(Max, a[i]);
        if(a[i] &gt; Max) {
            Max = a[i];
            maxCounts = 1;
        } else if(a[i] == Max) maxCounts++;
        Min = min(Min, a[i]);
        sum += a[i];
    }

    if((Max - Min ==  k + 1 &amp;&amp; maxCounts &gt; 1) || Max - Min &gt; k + 1) {
        cout &lt;&lt; win[1] &lt;&lt; endl;
        return;
    }

    //直接通过sum奇偶性判断输家
    if(sum &amp; 1) cout &lt;&lt; win[0] &lt;&lt; endl;
    else cout &lt;&lt; win[1] &lt;&lt; endl;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while(t--) solution();
    return 0;
}

```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-bo-yi.html</guid><pubDate>Tue, 06 May 2025 13:39:11 +0000</pubDate></item><item><title>为使正逆字符的字典序符合条件进行操作</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/wei-shi-zheng-ni-zi-fu-de-zi-dian-xu-fu-he-tiao-jian-jin-xing-cao-zuo.html</link><description>## 问题：

* **定义一种特殊的字符串正序字典序小于逆序字符串的字典序，现在给定一个字符串（长度为n， 只包含小写字符），在给定一个操作次数k，进行如下操作：**

  * 选定i，j两个坐标进行字符反转，如果两者相等就不进行任何操作

  **问：经过k次操作后该字符串能否变成特殊的字符串？**

## 思路：

* ### 进行分类讨论：

  1. 简单的，字符长度为1肯定是“NO”
  2. 给定的字符串有可能直接就是符合条件的特殊字符串
  3. 对给定的字符串进行操作：

      1. 对于非回文字符串，若不符合条件交换正序与逆序第一个不同的字符串就可以符合条件了（😭我眼泪怎么止不住了？）
      2. 对于回文字符串（旨在解决上一个操作无法解决的问题，也就是说先想到了解决方法，然后找到了特解进行修补？不确定），如果不符合条件，就把相邻的两个不同的字符交换就可以了
  4. **综上所述：直接判原字符串是否符合条件秒杀1、2类，检查最大最小值是否相同就秒杀了3类（第三类实质上都是对不同字符的一次操作解决的）**

## 反思：🚩

* 作为一道甚至说是“简单”级别的构造题，我做了很久，至少一个半小时。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/wei-shi-zheng-ni-zi-fu-de-zi-dian-xu-fu-he-tiao-jian-jin-xing-cao-zuo.html</guid><pubDate>Mon, 05 May 2025 13:08:56 +0000</pubDate></item><item><title>循环移位操作下排列中固定点的问题（真的吃力😓）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/xun-huan-yi-wei-cao-zuo-xia-pai-lie-zhong-gu-ding-dian-de-wen-ti-%EF%BC%88-zhen-de-chi-li-%F0%9F%98%93%EF%BC%89.html</link><description>## 模运算：

* ### 定义

  a除以b的余数定义为a mod b

  满足交换律、结合律还有分配律

## 排列与组合

* ### 排列：

  从n个不同元素中取出 m（m &lt;= n）个元素，**&lt;u&gt;按照一定的顺序排成一列&lt;/u&gt;**，叫做从n个不同元素中取出m个元素的一个排列。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/xun-huan-yi-wei-cao-zuo-xia-pai-lie-zhong-gu-ding-dian-de-wen-ti-%EF%BC%88-zhen-de-chi-li-%F0%9F%98%93%EF%BC%89.html</guid><pubDate>Mon, 05 May 2025 09:19:45 +0000</pubDate></item><item><title>再观补码与数据极限</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zai-guan-bu-ma-yu-shu-ju-ji-xian.html</link><description>## 求补码的方法：

* **正数**：正数的原码、反码和补码都相同，符号位始终为 0 不变。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zai-guan-bu-ma-yu-shu-ju-ji-xian.html</guid><pubDate>Mon, 05 May 2025 02:06:36 +0000</pubDate></item><item><title>2025/5/4周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-4-zhou-ji.html</link><description>周日这天搭建了自己的博客，希望有一天可以自己为博客写一个UI系统，自己的设计也太酷了吧！

**算法**还是有点有基础不牢地动山摇了，我觉得之后要一点一点好好**从基础学起**了

还有**算法题**。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-4-zhou-ji.html</guid><pubDate>Sun, 04 May 2025 14:19:16 +0000</pubDate></item><item><title>环状数组（双数组模拟环）（字典序）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/huan-zhuang-shu-zu-%EF%BC%88-shuang-shu-zu-mo-ni-huan-%EF%BC%89%EF%BC%88-zi-dian-xu-%EF%BC%89.html</link><description>![Image](https://github.com/user-attachments/assets/c0cd669f-ab49-4b72-803a-478161e4b9c1)

&gt; 所谓字典序，就是字符串在字典中的顺序。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/huan-zhuang-shu-zu-%EF%BC%88-shuang-shu-zu-mo-ni-huan-%EF%BC%89%EF%BC%88-zi-dian-xu-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 09:16:52 +0000</pubDate></item><item><title>生成元（使用哈希表提高大量数据的处理效率）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/sheng-cheng-yuan-%EF%BC%88-shi-yong-ha-xi-biao-ti-gao-da-liang-shu-ju-de-chu-li-xiao-lv-%EF%BC%89.html</link><description>### 问题：

&gt; x加x的各个数字得到y，就说x是y的生成元。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/sheng-cheng-yuan-%EF%BC%88-shi-yong-ha-xi-biao-ti-gao-da-liang-shu-ju-de-chu-li-xiao-lv-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 08:06:33 +0000</pubDate></item><item><title>输入string转vector</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-ru-string-zhuan-vector.html</link><description>### C++中读取字符串为`vector&lt;char&gt;`的方法：

```cpp
string input;
getline(cin, input); // cin &gt;&gt; input
vector&lt;char&gt; charVector(input.begin(), input.end());
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-ru-string-zhuan-vector.html</guid><pubDate>Sun, 04 May 2025 07:32:51 +0000</pubDate></item><item><title>回文与镜像（字符串的灵活使用）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/hui-wen-yu-jing-xiang-%EF%BC%88-zi-fu-chuan-de-ling-huo-shi-yong-%EF%BC%89.html</link><description>![Image](https://github.com/user-attachments/assets/d7cc37ad-718d-4f77-b57a-9d5cc47ae942){style='width:50%;'}

* 镜像可以用一个字符串`rev`表示出来，做镜像就可以直接取字母序号对应的字符来进行替换。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/hui-wen-yu-jing-xiang-%EF%BC%88-zi-fu-chuan-de-ling-huo-shi-yong-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 07:25:36 +0000</pubDate></item><item><title>dijkstra（朴素版）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-pu-su-ban-%EF%BC%89.html</link><description>&gt; `dijkstra`在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-pu-su-ban-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 04:50:57 +0000</pubDate></item></channel></rss>