<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Break_M</title><link>https://lsh-NJ.github.io/breakMO.github.io</link><description>你想度过，怎么样的一生？</description><copyright>Break_M</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://tse4.mm.bing.net/th/id/OIP.lKmqCoEUSaq-GtTpYi8s3wHaEd?cb=iwp1&amp;rs=1&amp;pid=ImgDetMain</url><title>avatar</title><link>https://lsh-NJ.github.io/breakMO.github.io</link></image><lastBuildDate>Mon, 14 Jul 2025 11:07:56 +0000</lastBuildDate><managingEditor>Break_M</managingEditor><ttl>60</ttl><webMaster>Break_M</webMaster><item><title>DFS+记忆化（DP）在矩阵中找到最长递减路径的长度</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/DFS%2B-ji-yi-hua-%EF%BC%88DP%EF%BC%89-zai-ju-zhen-zhong-zhao-dao-zui-chang-di-jian-lu-jing-de-chang-du.html</link><description># DFS+记忆化（DP）

- 使用动态规划记录每个节点的最大长度，当再次搜索到该节点的时候就可以直接返回值了。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/DFS%2B-ji-yi-hua-%EF%BC%88DP%EF%BC%89-zai-ju-zhen-zhong-zhao-dao-zui-chang-di-jian-lu-jing-de-chang-du.html</guid><pubDate>Mon, 14 Jul 2025 11:07:26 +0000</pubDate></item><item><title>f[i]=f[i/2]+f[i%2];(i&gt;=2)给定i，输出f[i]和最小出现该值的位置</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/f%5Bi%5D%3Df%5Bi-2%5D%2Bf%5Bi%252%5D%3B%28i-%3D2%29-gei-ding-i%EF%BC%8C-shu-chu-f%5Bi%5D-he-zui-xiao-chu-xian-gai-zhi-de-wei-zhi.html</link><description>&lt;html&gt;
&lt;body&gt;
&lt;!--StartFragment--&gt;&lt;h1 id='小q的数列' updated='20250714164549'&gt;&lt;a href='https://ac.nowcoder.com/acm/problem/15979'&gt;小q的数列&lt;/a&gt;&lt;/h1&gt;
&lt;h4 id='思路-' updated='20250714180138'&gt;思路：&lt;/h4&gt;
&lt;ul id='20250714180141-jue799l' updated='20250714180142'&gt;
&lt;li id='20250714180142-9niq7j4' updated='20250714180142'&gt;
&lt;p id='20250714180142-hg2k2qr' updated='20250714180210'&gt;发现f(n)值只与二进制的1的个数有关：&lt;/p&gt;
&lt;pre&gt;&lt;code class='language-cpp'&gt;while(n &amp;gt; 0) {
    n -= (n &amp;amp; -n);
    res++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li id='20250714180714-757cpnu' updated='20250714180714'&gt;
&lt;p id='20250714180714-lsct8aj' updated='20250714181002'&gt;位置肯定是由res推出的，发现:&lt;span data-type='code'&gt;n = (1ll &amp;lt;&amp;lt; res) - 1;&lt;/span&gt;​&lt;/p&gt;

res | n
-- | --
0 | 0
1 | 1
2 | 3
3 | 7
4 | 15


&lt;/li&gt;
&lt;/ul&gt;
&lt;p id='20250714164550-mk6nxvw' updated='20250714164550'&gt;&lt;/p&gt;
&lt;!--EndFragment--&gt;
&lt;/body&gt;
。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/f%5Bi%5D%3Df%5Bi-2%5D%2Bf%5Bi%252%5D%3B%28i-%3D2%29-gei-ding-i%EF%BC%8C-shu-chu-f%5Bi%5D-he-zui-xiao-chu-xian-gai-zhi-de-wei-zhi.html</guid><pubDate>Mon, 14 Jul 2025 10:11:54 +0000</pubDate></item><item><title>裴蜀定理</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/pei-shu-ding-li.html</link><description>裴蜀定理（Bézout's Identity）是数论中一个基础且重要的定理，描述了两个整数与其最大公因数之间的线性关系。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/pei-shu-ding-li.html</guid><pubDate>Sun, 13 Jul 2025 17:54:38 +0000</pubDate></item><item><title>与左右边界相同位数数字相同的最小数量</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/yu-zuo-you-bian-jie-xiang-tong-wei-shu-shu-zi-xiang-tong-de-zui-xiao-shu-liang.html</link><description># [[ 2121E - Sponsor of Your 问题集](https://codeforces.com/problemset/problem/2121/E)](https://codeforces.com/problemset/problem/2121/E)

#### 思路：

- 对于l.r相同的前缀，x必定都相同，所以答案加上相同前缀长度的两倍
- 到第一个不同的元素，发现有两种状态：

  1. r比l大2，x一定可以和两个元素都不相同，并且因为后面的数无论是什么都不会超出边界，所以不对已有答案进行更改。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/yu-zuo-you-bian-jie-xiang-tong-wei-shu-shu-zi-xiang-tong-de-zui-xiao-shu-liang.html</guid><pubDate>Sun, 13 Jul 2025 10:13:25 +0000</pubDate></item><item><title>对数组进行n次删除每次对应的MEX可能值的个数</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/dui-shu-zu-jin-xing-n-ci-shan-chu-mei-ci-dui-ying-de-MEX-ke-neng-zhi-de-ge-shu.html</link><description># [[ E - MEX Count](https://codeforces.com/contest/2123/problem/E)](https://codeforces.com/contest/2123/problem/E)

- #### 思路一:

  1. MEX是连续的从零开始的数的第一个未出现的数，则要得到相应k下的MEX可能值需要一个连续的数组。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/dui-shu-zu-jin-xing-n-ci-shan-chu-mei-ci-dui-ying-de-MEX-ke-neng-zhi-de-ge-shu.html</guid><pubDate>Sat, 12 Jul 2025 08:21:41 +0000</pubDate></item><item><title>差分数组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/cha-fen-shu-zu.html</link><description>差分数组是一种用于高效**&lt;u&gt;处理数组区间更新和查询&lt;/u&gt;**的辅助数据结构，尤其在需要对数组的多个连续区间进行增减操作时，能显著降低时间复杂度。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/cha-fen-shu-zu.html</guid><pubDate>Sat, 12 Jul 2025 07:55:09 +0000</pubDate></item><item><title>二进制字符清零博弈</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/er-jin-zhi-zi-fu-qing-ling-bo-yi.html</link><description># [[D — Binary String Battle](https://codeforces.com/contest/2123/problem/D)](https://codeforces.com/contest/2123/problem/D)

#### 思路:

- cnt &lt; k时Alice必定胜利
- Bob胜利需要找到一个连续的k个都为0的位置。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/er-jin-zhi-zi-fu-qing-ling-bo-yi.html</guid><pubDate>Fri, 11 Jul 2025 13:08:19 +0000</pubDate></item><item><title>一定可以取出a行b列元素单一子矩阵的矩阵行列数（元素限制在1~k中）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/yi-ding-ke-yi-qu-chu-a-xing-b-lie-yuan-su-dan-yi-zi-ju-zhen-de-ju-zhen-xing-lie-shu-%EF%BC%88-yuan-su-xian-zhi-zai-1~k-zhong-%EF%BC%89.html</link><description># [[2120D — Matrix Game](https://codeforces.com/contest/2120/problem/D)](https://codeforces.com/contest/2120/problem/D)

 关键词：#84 鸽笼原理，#85 组合，元组，模运算的组合数，乘法逆元，费马小定理，#86 快速幂算法

## 思路：

- ### 先考虑**在一列中的重复现象：**

  数字为1~k，共有n个位置。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/yi-ding-ke-yi-qu-chu-a-xing-b-lie-yuan-su-dan-yi-zi-ju-zhen-de-ju-zhen-xing-lie-shu-%EF%BC%88-yuan-su-xian-zhi-zai-1~k-zhong-%EF%BC%89.html</guid><pubDate>Fri, 11 Jul 2025 04:17:30 +0000</pubDate></item><item><title>快速幂（带模）算法</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/kuai-su-mi-%EF%BC%88-dai-mo-%EF%BC%89-suan-fa.html</link><description># 核心原理：指数的二进制分解

根据幂的运算法则 $a^{m+n} = a^m \times a^n$，可得：$a^b = a^{2^{k_1}} \times a^{2^{k_2}} \times \dots \times a^{2^{k_n}}$。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/kuai-su-mi-%EF%BC%88-dai-mo-%EF%BC%89-suan-fa.html</guid><pubDate>Fri, 11 Jul 2025 04:10:13 +0000</pubDate></item><item><title>模环境下的组合数/乘法逆元</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/mo-huan-jing-xia-de-zu-he-shu---cheng-fa-ni-yuan.html</link><description># 乘法逆元
- ## 概念：

  当存在整数a和mod且二者互质时，会有一个整数b满足`a * b ≡ 1 (mod mod)`，此时b就被称为a在模mod下的逆元，可以表示为`inv[a]`

- ## 递推公式：

  1. `inv[i] = (mod - mod/i) * inv[mod%i] % mod`，`b = inv[a]`，b就是a的倒数
  2. 根据费马小定理使用快速幂求解：`b = fast_pow_mod((i + mod) % mod, mod - 2) % mod;`

&gt; **对于mod的值：** mod必须是一个质数，不然有些数可能不存在逆元
&gt;
&gt; **对于递推公式1：** 要初始化`inv[1] = 1`
# 模环境下的组合数
- ## 基本算式：

  1. 整体：$\frac{n！}{a！\cdot\left(n-a\right)!}$，可以写成$\frac{n\cdot\left(n-1\right)...\left(n-a+1\right)}{a\cdot\left(a-1\right)...2\cdot1}$，上下同是a项式

- ## 一、费马小定理：

   **`x^(mod-2) mod mod`** ：计算 `x` 在模 `mod` 下的逆元，即 `x^(mod-2) % mod`。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/mo-huan-jing-xia-de-zu-he-shu---cheng-fa-ni-yuan.html</guid><pubDate>Fri, 11 Jul 2025 04:01:48 +0000</pubDate></item><item><title>鸽笼原理（Pigeonhole Principle）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/ge-long-yuan-li-%EF%BC%88Pigeonhole%20Principle%EF%BC%89.html</link><description>
鸽笼原理是组合数学中一个基础且应用广泛的原理，其核心思想简单直观，但能解决许多看似复杂的问题。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/ge-long-yuan-li-%EF%BC%88Pigeonhole%20Principle%EF%BC%89.html</guid><pubDate>Fri, 11 Jul 2025 03:52:31 +0000</pubDate></item><item><title>构造节点路径最小编号和确定的树</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/gou-zao-jie-dian-lu-jing-zui-xiao-bian-hao-he-que-ding-de-shu.html</link><description># [[ C - Divine Tree](https://codeforces.com/contest/2120/problem/C)](https://codeforces.com/contest/2120/problem/C)

# 思路:

- 构成单线就可以了，不用复杂的二叉树。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/gou-zao-jie-dian-lu-jing-zui-xiao-bian-hao-he-que-ding-de-shu.html</guid><pubDate>Thu, 10 Jul 2025 12:32:39 +0000</pubDate></item><item><title>获得不等于原数组集合但最接近原集合的数组集合</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/huo-de-bu-deng-yu-yuan-shu-zu-ji-he-dan-zui-jie-jin-yuan-ji-he-de-shu-zu-ji-he.html</link><description># [[1882B - Sets and Union](https://codeforces.com/contest/1882/problem/B)](https://codeforces.com/contest/1882/problem/B)

#### 原来的思路：

- 删除特有元素最少的一个数组

#### 正确的思路：

- 尝试对每一个元素进行删除，检查删除以后剩余元素种类的最大值。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/huo-de-bu-deng-yu-yuan-shu-zu-ji-he-dan-zui-jie-jin-yuan-ji-he-de-shu-zu-ji-he.html</guid><pubDate>Wed, 09 Jul 2025 15:19:48 +0000</pubDate></item><item><title>Mi,j = ai | aj，给定矩阵M，求数组a是否存在</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/Mi%2Cj%20%3D%20ai%20-%20aj%EF%BC%8C-gei-ding-ju-zhen-M%EF%BC%8C-qiu-shu-zu-a-shi-fou-cun-zai.html</link><description># [[1903B - StORage room](https://codeforces.com/problemset/problem/1903/B)](https://codeforces.com/problemset/problem/1903/B)

#### 思路:

- ai | aj = Mi,j ，则说明 Mi,j 二进制中的 1 分式中可能有 1 ，二进制中的 0 分式中不可能有 1 ，就想到可以让有关任意 i 的 Mi,j 进行“累&amp;”操作，获得可以满足要求的 ai
- 之后再检查是否满足条件就可以了


#### 为什么要进行检查？

- 题目中明确说明存在无法构造的情况。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/Mi%2Cj%20%3D%20ai%20-%20aj%EF%BC%8C-gei-ding-ju-zhen-M%EF%BC%8C-qiu-shu-zu-a-shi-fou-cun-zai.html</guid><pubDate>Tue, 08 Jul 2025 23:14:43 +0000</pubDate></item><item><title>任意数组对于何数的模只有两个结果？</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/ren-yi-shu-zu-dui-yu-he-shu-de-mo-zhi-you-liang-ge-jie-guo-%EF%BC%9F.html</link><description># [[1909B - Make Almost Equal With Mod](https://codeforces.com/problemset/problem/1909/B)](https://codeforces.com/problemset/problem/1909/B)

### 关键知识：🔺

- mod $2^{n}$运算相当于 `X &amp; (n - 1)`

#### 思路：

- 要得到两种不同的余数找到第一个不相同的二进制位置就可以了。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/ren-yi-shu-zu-dui-yu-he-shu-de-mo-zhi-you-liang-ge-jie-guo-%EF%BC%9F.html</guid><pubDate>Tue, 08 Jul 2025 12:22:36 +0000</pubDate></item><item><title>二重全排列左右子序列的按位异或相同子数组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/er-zhong-quan-pai-lie-zuo-you-zi-xu-lie-de-an-wei-yi-huo-xiang-tong-zi-shu-zu.html</link><description># [[1944B - Equal XOR](https://codeforces.com/problemset/problem/1944/B)](https://codeforces.com/problemset/problem/1944/B)

#### 思路:

- 按位异或，奇1偶0，加两个相同的数没有任何贡献，因此首先把所有相同的数添加到队列中。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/er-zhong-quan-pai-lie-zuo-you-zi-xu-lie-de-an-wei-yi-huo-xiang-tong-zi-shu-zu.html</guid><pubDate>Tue, 08 Jul 2025 12:11:27 +0000</pubDate></item><item><title>给定和按位或二进制表示1最多的序列</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/gei-ding-he-an-wei-huo-er-jin-zhi-biao-shi-1-zui-duo-de-xu-lie.html</link><description># [[1957B - A BIT of a Construction](https://codeforces.com/problemset/problem/1957/B)](https://codeforces.com/problemset/problem/1957/B)

#### 思维漏洞：

- 比n小的数一定存在除了二进制最高位外都是1的数，所以要想加数的1最多，在n二进制位具有的0大于等于2时就需要这个低位全是1的数了。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/gei-ding-he-an-wei-huo-er-jin-zhi-biao-shi-1-zui-duo-de-xu-lie.html</guid><pubDate>Tue, 08 Jul 2025 10:45:39 +0000</pubDate></item><item><title>按位异或与按位与结果相同的最小字典序数组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/an-wei-yi-huo-yu-an-wei-yu-jie-guo-xiang-tong-de-zui-xiao-zi-dian-xu-shu-zu.html</link><description># [[C - A Good 问题](https://codeforces.com/contest/2119/problem/C)](https://codeforces.com/contest/2119/problem/C)

# 关键：

- 按位与的结果与按位异或的结果相同，需要考虑两者的特性（对于每一个二进制位）：

  1. 按位与有0结果就是0
  2. 按位异或看1的数量，奇数个就是1，偶数个就是0
- 对于数组的长度为奇数，为让字典序最小，可以让所有数都相同且等于左边界，此时满足条件。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/an-wei-yi-huo-yu-an-wei-yu-jie-guo-xiang-tong-de-zui-xiao-zi-dian-xu-shu-zu.html</guid><pubDate>Mon, 07 Jul 2025 10:29:21 +0000</pubDate></item><item><title>n条给定长度的边能否链接两个点</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/n-tiao-gei-ding-chang-du-de-bian-neng-fou-lian-jie-liang-ge-dian.html</link><description># [[ B - Line Segments](https://codeforces.com/contest/2119/problem/B)](https://codeforces.com/contest/2119/problem/B)

# 关键：

将问题转化为n + 1条边是否能组成多边形或退化多边形的问题（拿三角形分析最简单）

并且并不需要拿出具体的方案，只需要判断存在性，这n+1条边中的最大值只要不大于其余所有边的和就一定能组成多边形或退化多边形。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/n-tiao-gei-ding-chang-du-de-bian-neng-fou-lian-jie-liang-ge-dian.html</guid><pubDate>Mon, 07 Jul 2025 09:17:09 +0000</pubDate></item><item><title>加1与异或1</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/jia-1-yu-yi-huo-1.html</link><description># [[ A - Add or XOR](https://codeforces.com/contest/2119/problem/A)](https://codeforces.com/contest/2119/problem/A)

# 关键：

- 偶数按位异或1相当于加一，奇数相当于减一。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/jia-1-yu-yi-huo-1.html</guid><pubDate>Mon, 07 Jul 2025 07:58:33 +0000</pubDate></item><item><title>改写二进制为-1/1/0非零不连续序列</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/gai-xie-er-jin-zhi-wei--1-1-0-fei-ling-bu-lian-xu-xu-lie.html</link><description># [[ B - Binary Colouring](https://codeforces.com/contest/1977/problem/B)](https://codeforces.com/contest/1977/problem/B)

#### 思路:

1. 要用0，1，-1构成的非零不连续序列（相邻位置不能为非零数）代替二进制序列，发现1 -1 0 0可以代替1 0 0，1 0 -1 0可以代替1 1 0；可见这种操作可以在1连续时满足条件。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/gai-xie-er-jin-zhi-wei--1-1-0-fei-ling-bu-lian-xu-xu-lie.html</guid><pubDate>Mon, 07 Jul 2025 05:31:52 +0000</pubDate></item><item><title>a数组相邻项&amp;得到b，给定b构造a</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/a-shu-zu-xiang-lin-xiang-%26-de-dao-b%EF%BC%8C-gei-ding-b-gou-zao-a.html</link><description># [[1991B - AND Reconstruction](https://codeforces.com/problemset/problem/1991/B)](https://codeforces.com/problemset/problem/1991/B)

#### 思路：

- bi限定了ai和ai+1二进制必须有1的位置。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/a-shu-zu-xiang-lin-xiang-%26-de-dao-b%EF%BC%8C-gei-ding-b-gou-zao-a.html</guid><pubDate>Sun, 06 Jul 2025 09:57:25 +0000</pubDate></item><item><title>无数块中给定块两两匹配最大距离的最小值</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/wu-shu-kuai-zhong-gei-ding-kuai-liang-liang-pi-pei-zui-da-ju-li-de-zui-xiao-zhi.html</link><description># [[Black Cells](https://codeforces.com/problemset/problem/2026/B)](https://codeforces.com/problemset/problem/2026/B)

- 显然偶数顺序固定，直接输出最大值就可
- 对于奇数，我们可以选定其中的一个格子与不在队列中的白格匹配，剩余的格子应变成一个偶数排列，或两个偶数排列（两个奇数排列显然达不到最小的要求），可以通过统计最大前后缀的方式来暴力记录满足条件的最小值。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/wu-shu-kuai-zhong-gei-ding-kuai-liang-liang-pi-pei-zui-da-ju-li-de-zui-xiao-zhi.html</guid><pubDate>Sun, 06 Jul 2025 08:46:31 +0000</pubDate></item><item><title>涉及模运算的矩阵同化</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/she-ji-mo-yun-suan-de-ju-zhen-tong-hua.html</link><description># [[1983B - Corner Twist](https://codeforces.com/problemset/problem/1983/B)](https://codeforces.com/problemset/problem/1983/B)

#### 关键思路:

- 之前有过这样的解法，可以一点一点处理，因为后续处理存在不影响前面的必然性。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/she-ji-mo-yun-suan-de-ju-zhen-tong-hua.html</guid><pubDate>Sat, 05 Jul 2025 09:42:51 +0000</pubDate></item><item><title>计算保底赌博盈利</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/ji-suan-bao-di-du-bo-ying-li.html</link><description># [[1974D - Ingenuity-2](https://codeforces.com/problemset/problem/1974/D)](https://codeforces.com/problemset/problem/1974/D)

#### 解题思路：

- 要时刻保证最坏的情况下依旧可以盈利，这样就需要每一次投入都满足`当前投入*（k - 1）&gt; 之前的投入总和`

#### 问题：

- 在使每一次投入都满足要求时，不要使用while每次都进行拟合，直接`curin = sumin / (k - 1) + 1;`就可以了，明显递增不是线性的，`while`的拟合难免会有渐进的复杂度。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/ji-suan-bao-di-du-bo-ying-li.html</guid><pubDate>Sat, 05 Jul 2025 08:08:03 +0000</pubDate></item><item><title>摸内存数量未知的盒子的最小操作数</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/mo-nei-cun-shu-liang-wei-zhi-de-he-zi-de-zui-xiao-cao-zuo-shu.html</link><description># [[2024B - Buying Lemonade](https://codeforces.com/problemset/problem/2024/B)](https://codeforces.com/problemset/problem/2024/B)

#### 思路：

- 要得到的是&lt;u&gt;拿到至少 k 罐所需的最少按钮次数&lt;/u&gt;，要思考一个**对于不知道排列情况的人面对问题的解决方法**，盲目地排序，然后从小开始取得不到最少次数，或从最大开始取具有运气成分（对于不了解排序的人来说这两种操作都不现实）

  但我们可以通过每个口取一个的方式来尽量在没有运气成分的条件下的尽量小的操作数。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/mo-nei-cun-shu-liang-wei-zhi-de-he-zi-de-zui-xiao-cao-zuo-shu.html</guid><pubDate>Fri, 04 Jul 2025 07:48:51 +0000</pubDate></item><item><title>bitwiseOR运算——相邻两位按位或为给定值的最长数组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/bitwiseOR-yun-suan-%E2%80%94%E2%80%94-xiang-lin-liang-wei-an-wei-huo-wei-gei-ding-zhi-de-zui-chang-shu-zu.html</link><description># [[1988C - Increasing Sequence with Fixed OR](https://codeforces.com/problemset/problem/1988/C)](https://codeforces.com/problemset/problem/1988/C)

- C++的`long long`类型可以接受最多**&lt;u&gt;63&lt;/u&gt;**次`&lt;&lt;`运算！！！
- 对$2^{n}$进行移位运算时1要是`long long`类型，防止数值循环导致错误
- `1 &lt;&lt; -1`虽然未定义，但可以认为结果是0

#### 解题：

- 第一个数不能占用最高位
- 每相邻的两个数`|`，意味着`n`的每个二进制1至少需要一个数具有，且要满足递增的条件，可以想到对n的所有二进制1进行挖空，要使符合要求的数组最长，每次只挖一个空可以使得梯度最小

  且需要注意当n为$2^{n}$时挖空会得到不是正整数的0，因此要`(x != n)`避免这种情况

  ```cpp
  	vector&lt;long long&gt; res;
          for(int i = 62; i &gt;= -1; i--) {
              long long x = (long long)1 &lt;&lt; i;
              if((x &amp; n) == x &amp;&amp; (x != n)) {
                  res.push_back(n - x);
              }
          }
  ```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/bitwiseOR-yun-suan-%E2%80%94%E2%80%94-xiang-lin-liang-wei-an-wei-huo-wei-gei-ding-zhi-de-zui-chang-shu-zu.html</guid><pubDate>Fri, 04 Jul 2025 03:31:25 +0000</pubDate></item><item><title>数组减有限次数固定的数取绝对值的归零</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-jian-you-xian-ci-shu-gu-ding-de-shu-qu-jue-dui-zhi-de-gui-ling.html</link><description>[[C - Turtle and Good Pairs](https://codeforces.com/contest/2003/problem/C)](https://codeforces.com/contest/2003/problem/C)

#### 新知：

- 对于每个数的范围都在$[0,2^{n}]$的一个数组，可以从2的n - 1次方一直减到0次方取绝对值来使整个数组的数都为0（不断缩小范围，最后的数全为0或全为1）

- 对于$2^{n}$的快速获取`1 &lt;&lt; i`更便捷。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-jian-you-xian-ci-shu-gu-ding-de-shu-qu-jue-dui-zhi-de-gui-ling.html</guid><pubDate>Thu, 03 Jul 2025 12:53:44 +0000</pubDate></item><item><title>“好对”字符串</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/%E2%80%9C-hao-dui-%E2%80%9D-zi-fu-chuan.html</link><description>[[C - Turtle and Good Pairs](https://codeforces.com/contest/2003/problem/C)](https://codeforces.com/contest/2003/problem/C)

1. 难点在于数学公式推导，假设字符串由k个相同字符组成的字符串组成，如`aabcc`，由{1，2}，{3，3}，{4，5}的三个相同字符的字符串组成。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/%E2%80%9C-hao-dui-%E2%80%9D-zi-fu-chuan.html</guid><pubDate>Thu, 03 Jul 2025 10:30:34 +0000</pubDate></item><item><title>组合购买折扣（二分做法）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zu-he-gou-mai-zhe-kou-%EF%BC%88-er-fen-zuo-fa-%EF%BC%89.html</link><description>[[C - Action Figures](https://codeforces.com/contest/2026/problem/C)](https://codeforces.com/contest/2026/problem/C)

#### 如何使用二分法暴力解决问题？

1. 本质上是解决暴力寻找在满足条件的前提下的最值问题

    ```cpp
    	int l = 1;
        int r = count_1 + 1;
        while(r - l &gt; 1)
        {
            int mid = (l + r) / 2;
            if(can(s, mid))//判断是否符合条件
                l = mid;
            else
                r = mid;
        }
    ```

#### 本题要满足的条件：

1. k值一定时，有没有足够的组合物

    ```cpp
    bool can(const string&amp; s, int k)
    {
        int n = s.size();
        vector&lt;int&gt; used(n);
        for(int i = n - 1; i &gt;= 0; i--)
            if(k &gt; 0 &amp;&amp; s[i] == '1')
            {
                used[i] = 1;
                k--;
            }
        int cur = 0;
        for(int i = 0; i &lt; n; i++)
            if(used[i])
            {
                cur--;
                if(cur &lt; 0) return false;
            }
            else cur++;
        return true;
    } 
    ```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zu-he-gou-mai-zhe-kou-%EF%BC%88-er-fen-zuo-fa-%EF%BC%89.html</guid><pubDate>Thu, 03 Jul 2025 09:03:55 +0000</pubDate></item><item><title>2025/7/3周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-7-3-zhou-ji.html</link><description>&lt;sub&gt;这是一篇迟到的周记……&lt;/sub&gt;

	完成了期末周考试，终于闲下来了。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-7-3-zhou-ji.html</guid><pubDate>Thu, 03 Jul 2025 06:19:06 +0000</pubDate></item><item><title>交互猜测二进制字符串</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/jiao-hu-cai-ce-er-jin-zhi-zi-fu-chuan.html</link><description>[[C - Password Cracking](https://codeforces.com/contest/2013/problem/C)](https://codeforces.com/contest/2013/problem/C)

## 关键点：

1. 先确定一个字符，再向右扩展，向左扩展，向右询问两次因为要找到后缀，向左不需要，只要长度够就可以了
2. bug：

    - 在长度为1的情况下违反题目描述中的长度限制
    - 向右拓展的过程中如果子串不仅仅是后缀，而且是完整字符，判断的过程也会违反长度限制

## 代码：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
//4
//0100
int main() {
    int t; cin &gt;&gt; t;
    while(t--) {
        int n; cin &gt;&gt; n;
        bool in;
        string res = '0';
        //第一次操作：
        cout &lt;&lt; '? ' &lt;&lt; res &lt;&lt; endl;
        cin &gt;&gt; in;
        if(!in) res = '1';
        if(n == 1) {
            cout &lt;&lt; '! ' &lt;&lt; res &lt;&lt; endl;
            continue;
        }
        //检查后缀
        bool zero, one;
        while(1) {

            cout &lt;&lt; '? ' &lt;&lt; res &lt;&lt; '0' &lt;&lt; endl;
            cin &gt;&gt; zero;

            cout &lt;&lt; '? ' &lt;&lt; res &lt;&lt; '1' &lt;&lt; endl;
            cin &gt;&gt; one;

            if((!zero &amp;&amp; !one)) {
                break;
            }
            else if(zero) {
                res += '0';
            }
            else res += '1';
            if(res.size() == n) break;
        }
        int size = res.size();
        while(size &lt; n) {

            cout &lt;&lt; '? ' &lt;&lt; '0' &lt;&lt; res  &lt;&lt; endl;
            cin &gt;&gt; zero;

            if(zero) {
                res = '0' + res;
            }
            else res = '1' + res;
            size++;
        }

        cout &lt;&lt; '! ' &lt;&lt; res &lt;&lt; endl;
        cout.flush();
    }
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/jiao-hu-cai-ce-er-jin-zhi-zi-fu-chuan.html</guid><pubDate>Thu, 03 Jul 2025 06:12:11 +0000</pubDate></item><item><title>2025/6/22周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-6-22-zhou-ji.html</link><description>期末周尽力了。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-6-22-zhou-ji.html</guid><pubDate>Mon, 23 Jun 2025 11:52:16 +0000</pubDate></item><item><title>矩阵中消耗最小的区域（二维前缀和）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/ju-zhen-zhong-xiao-hao-zui-xiao-de-qu-yu-%EF%BC%88-er-wei-qian-zhui-he-%EF%BC%89.html</link><description>[[跳转题目](https://codeforces.com/contest/2113/problem/C)](https://codeforces.com/contest/2113/problem/C)

## 思路:

- 只需要寻找一个空位炸掉的金矿最少，其余金矿就可以全部获得，因此要找的就是消耗最小的一个爆炸区域。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/ju-zhen-zhong-xiao-hao-zui-xiao-de-qu-yu-%EF%BC%88-er-wei-qian-zhui-he-%EF%BC%89.html</guid><pubDate>Mon, 16 Jun 2025 02:48:33 +0000</pubDate></item><item><title>2025/6/15周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-6-15-zhou-ji.html</link><description>	永远没有人可以避免被别人讨厌。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-6-15-zhou-ji.html</guid><pubDate>Sun, 15 Jun 2025 22:45:20 +0000</pubDate></item><item><title>R1031Dir.2赛后已做题目复盘</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/R1031Dir.2-sai-hou-yi-zuo-ti-mu-fu-pan.html</link><description>[[跳转比赛](https://codeforces.com/contest/2113)](https://codeforces.com/contest/2113)

# R1031Dir.2赛后已做题目复盘

## A

- ### 问题：

  1. 耗时过长
  2. 实现代码不完善导致扣分
- ### 成果：

  1. 写法优化：

      ```cpp
      int counts = 0;
      while(x &gt;= a) {//大于一个固定的数就减去另一个固定的数
      	x -= b;
      	counts++;
      }
      ```

      ```cpp
      int counts = max((x - a + b) / b, 0);
      ```

      可以使用数学不等式推导

## B

- ### 问题：

  1. 没有抓住问题的共同点
  2. 0的余数运算得零，思考这是否会对判断造成影响？即思考其实际物理意义。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/R1031Dir.2-sai-hou-yi-zuo-ti-mu-fu-pan.html</guid><pubDate>Sun, 15 Jun 2025 22:39:17 +0000</pubDate></item><item><title>给定边界内(x⊕y)+(x⊕z)+(y⊕z)的最大值</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/gei-ding-bian-jie-nei-%28x%E2%8A%95y%29%2B%28x%E2%8A%95z%29%2B%28y%E2%8A%95z%29-de-zui-da-zhi.html</link><description>&lt;html&gt;
&lt;body&gt;
&lt;!--StartFragment--&gt;&lt;p id='20250614083727-ufbiwbf' updated='20250614083746'&gt;&lt;a href='https://codeforces.com/contest/2057/problem/C'&gt;跳转题目&lt;/a&gt;&lt;/p&gt;
&lt;h2 id='思路-' updated='20250614083750'&gt;思路：&lt;/h2&gt;
&lt;ol id='20250614083751-2rkg9hg' updated='20250614083752'&gt;
&lt;li id='20250614083752-mzh3glk' updated='20250614083752'&gt;
&lt;h3 id='对于-x-y---x-z---y-z--要取得最大的结果-要求三个数的二进制表示尽可能有两个相同-即相同位置上两个1一个0或者两个0一个1-' updated='20250614090001'&gt;对于(x⊕y)+(x⊕z)+(y⊕z)，要取得最大的结果，要求三个数的二进制表示尽可能有两个相同，即相同位置上两个1一个0或者两个0一个1。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/gei-ding-bian-jie-nei-%28x%E2%8A%95y%29%2B%28x%E2%8A%95z%29%2B%28y%E2%8A%95z%29-de-zui-da-zhi.html</guid><pubDate>Sat, 14 Jun 2025 02:02:15 +0000</pubDate></item><item><title>构造行列均为全排列的n*n矩阵</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/gou-zao-xing-lie-jun-wei-quan-pai-lie-de-n-n-ju-zhen.html</link><description>[[跳转题目](https://codeforces.com/contest/2118/problem/B)](https://codeforces.com/contest/2118/problem/B)

## 思路：

1. 要想构造一个排列皆为全排列的`n * n`矩阵，考虑使其变成循环的形式：

    &gt; 1 2 3 4
    &gt;
    &gt; 2 3 4 1
    &gt;
    &gt; 3 4 1 2
    &gt;
    &gt; 4 1 2 3
    &gt;
2. 该如何通过反转构造出这样的矩阵呢？

    不好构造，想一想类似的更容易构造的循环形式

    &gt; 1 4 3 2
    &gt;
    &gt; 2 1 4 3
    &gt;
    &gt; 3 2 1 4
    &gt;
    &gt; 4 3 2 1
    &gt;

    （话说简单试一试就能试出来好吧？一个小时没发现这样的构造有点糖了吧？）

    按照层序递进的进行反转（`swap(1, i);swap(i + 1, n)`）可以看出是一种逆序的循环，可以满足`2n`操作数要求

## 代码:

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;

void work() {
    int n; cin &gt;&gt; n;
    vector&lt;vector&lt;int&gt;&gt; res;
    for(int i = 1; i &lt;= n; i++) {
        if(1 &lt; i) {
            res.push_back({i, 1, i});
        }
        if(i + 1 &lt; n) {
            res.push_back({i, i + 1, n});
        }
    }
    cout &lt;&lt; res.size() &lt;&lt;endl;
    for(vector&lt;int&gt; r : res) {
        cout &lt;&lt; r[0] &lt;&lt; ' ' &lt;&lt; r[1] &lt;&lt; ' ' &lt;&lt; r[2] &lt;&lt; endl;
    }
}

int main() {
    int t; cin &gt;&gt; t;
    while(t--) work();
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/gou-zao-xing-lie-jun-wei-quan-pai-lie-de-n-n-ju-zhen.html</guid><pubDate>Fri, 13 Jun 2025 12:54:12 +0000</pubDate></item><item><title>两种操作下使数组变成0的可能性（二分与数学经典）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/liang-zhong-cao-zuo-xia-shi-shu-zu-bian-cheng-0-de-ke-neng-xing-%EF%BC%88-er-fen-yu-shu-xue-jing-dian-%EF%BC%89.html</link><description>[[题目链接](https://codeforces.com/contest/2117/problem/D)](https://codeforces.com/contest/2117/problem/D)

## 思路：

- 要对数组进行`x`次`-i`操作和`y`次`-(n - i + 1)`操作，如果只看一种操作，想使得数组为零，数组肯定是单调的等差数组，所以肯定先要判断数组是否单调。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/liang-zhong-cao-zuo-xia-shi-shu-zu-bian-cheng-0-de-ke-neng-xing-%EF%BC%88-er-fen-yu-shu-xue-jing-dian-%EF%BC%89.html</guid><pubDate>Tue, 10 Jun 2025 13:01:58 +0000</pubDate></item><item><title>欧式距离与曼哈顿距离相等的点的个数（简单分析规律然后递归拆分）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/ou-shi-ju-li-yu-man-ha-dun-ju-li-xiang-deng-de-dian-de-ge-shu-%EF%BC%88-jian-dan-fen-xi-gui-lv-ran-hou-di-gui-chai-fen-%EF%BC%89.html</link><description>[[跳转题目](https://codeforces.com/problemset/problem/2072/E)](https://codeforces.com/problemset/problem/2072/E)

## 思路：

1. 假设有一排n个点，发现这n个点可以组成`n * (n - 1) / 2`对符合条件的组合，要组成`k`对，找一个最接近`k`的`n`来创建`n`个点，然后再对剩下的部分进行相同的操作，该过程可以递归进行，终止条件是参数`k`被削减为0

## 思维的桎梏：

1. 发现了一排点的规律，但是没有想到可以`y + 1`之后继续这个过程
2. 这是一个很经典的“递归拆分”问题，但我却卡在了拆分的起始点，我想的只有象限的四象限，而没有空间的无限延伸

## 代码：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;pair&lt;int,int&gt;&gt; res;
//通过对数构造一行点位
void creat(int num, int x, int y) {
    if(num == 0) return;
    int k = 2;//需要的点数
    while((k * (k - 1) / 2) &lt;= num) {
        k++;
    }
    k--;//需要的点数
    int tmp = k * (k - 1) / 2;
    for(int i = 1; i &lt;= k; i++) {
        res.push_back({x + i, y});
    }
    creat(num - tmp, x + k, y + 1);
}

void solution() {
    int k; cin &gt;&gt; k;
    creat(k,0, 0);
    cout &lt;&lt; res.size() &lt;&lt; endl;
    for(auto&amp; p:res) {
        cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; endl;
    }
    res.clear();
}

int main() {

    int t; cin &gt;&gt; t;
    while(t--) solution();
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/ou-shi-ju-li-yu-man-ha-dun-ju-li-xiang-deng-de-dian-de-ge-shu-%EF%BC%88-jian-dan-fen-xi-gui-lv-ran-hou-di-gui-chai-fen-%EF%BC%89.html</guid><pubDate>Tue, 10 Jun 2025 12:52:22 +0000</pubDate></item><item><title>双向距离最短的位置</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shuang-xiang-ju-li-zui-duan-de-wei-zhi.html</link><description>[[跳转题目](https://codeforces.com/contest/2098/problem/B)](https://codeforces.com/contest/2098/problem/B)

萨沙想在一条街道上购买一套公寓，这条街上的房屋从左到右编号为1到$10^9$。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shuang-xiang-ju-li-zui-duan-de-wei-zhi.html</guid><pubDate>Tue, 10 Jun 2025 11:06:23 +0000</pubDate></item><item><title>完全包含上一段数组元素切割的最大切割数</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/wan-quan-bao-han-shang-yi-duan-shu-zu-yuan-su-qie-ge-de-zui-da-qie-ge-shu.html</link><description>[[跳转题目](https://codeforces.com/contest/2117/problem/C)](https://codeforces.com/contest/2117/problem/C)

## 思路：

- 要构成组数最多的cool数组，可知每一组的元素种类个数都大于等于前一个数组的元素种类个数，这是要抓住的题目特点
- 从头开始用双指针的思想记录前后两组（pre、cur）的元素种类个数，有以下问题：

  1. 怎样记录：

      可以使用`unordered_map`，`unordered_map.size()`就是元素种类个数.
  2. 为什么不用set？

      根本考虑是效率和代码简洁性：`unordered_map[i]`如果不存在会默认初始化为0，有的数就可以手动标记为1（但是注意这种操作会影响map的大小，可能会对记录个数的操作产生影响，所以在使用以后要进行妥善处理），而`set.find()`查找速度不比哈希实现的`unordered_map`，且代码复杂。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/wan-quan-bao-han-shang-yi-duan-shu-zu-yuan-su-qie-ge-de-zui-da-qie-ge-shu.html</guid><pubDate>Sun, 08 Jun 2025 18:58:16 +0000</pubDate></item><item><title>2025/6/8周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-6-8-zhou-ji.html</link><description>	如果悲伤是一种会给别人造成麻烦的情绪，那我会戒掉的。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-6-8-zhou-ji.html</guid><pubDate>Sun, 08 Jun 2025 14:29:48 +0000</pubDate></item><item><title>最大交叉和与二叉树（😨）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zui-da-jiao-cha-he-yu-er-cha-shu-%EF%BC%88%F0%9F%98%A8%EF%BC%89.html</link><description>[[跳转题目](https://codeforces.com/problemset/problem/2114/E)](https://codeforces.com/problemset/problem/2114/E)

## 题目大意：

&gt; 给定一个二叉树，每个节点都有一个值，要求求出每个节点的最大交错和的值
&gt; 交错和差：`a[i] - a[parent[i]] + a[parent[...]-...`，当然，可以不包括父节点，`a[i]`本身也要考虑

## 思路：

- 最大交叉和可以以这样的思路进行：

  `max(该节点的值，该节点的值减去父节点的记录最小值)`，而其中的父节点的最小值是`min(该节点的值，该节点的值减去父节点的记录最大值)`。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zui-da-jiao-cha-he-yu-er-cha-shu-%EF%BC%88%F0%9F%98%A8%EF%BC%89.html</guid><pubDate>Sat, 07 Jun 2025 09:34:48 +0000</pubDate></item><item><title>通过取最大公约数取得使数组元素相同的最快步数</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/tong-guo-qu-zui-da-gong-yue-shu-qu-de-shi-shu-zu-yuan-su-xiang-tong-de-zui-kuai-bu-shu.html</link><description>[[跳转题目](https://codeforces.com/contest/2116/problem/C)](https://codeforces.com/contest/2116/problem/C)

## 题目大意：

&gt; 给定一个数组，可以进行如下操作，选定两个元素，使其中一个元素变为这两个元素的最大公约数，问，最少通过多少次操作可以使数组中的所有元素变为相同的值

# 思路：

1. 先通过预处理快速得出所有要用到的最大公约数
2. 所有数的最大公约数gcd(a1,a2,…,an)就是数组所有元素的最终值
3. 如果数组中已经存在一个元素等于gcd(a1,a2,…,an)，那么操作数就是数组长度减一了
4. 如果不存在，就要找一个使gcd(a1,a2,…,an)出现的最少的操作数，可以采用动态规划来完成

## 新知/问题：

- 如何**&lt;u&gt;*找到最少的操作数使得数组中的一个元素变为数组中的所有数的的最大公约数*&lt;/u&gt;**？怎样进行动态规划？

  1. 将数组中的所有数变为最大公约数的倍数，这样以来变成最大公约数就相当于数组元素变为1了
  2. 使用一个范围很大的数组（动规数组）存储接下来的操作数，初始化为一个较大的数
  3. 进行两层循环，第一层循环（看作gcd的左操作数）从最大的倍数开始一直到1，即是到最大公约数，第二层循环（看作gcd的右操作数）遍历所有数组元素，这个过程就在模拟对所有元素进行求最大公约数的过程
  4. 其动态规划的核心在于左右操作数的最大公约数记录为动规数组的左操作数加一
- 对数组的多次初始化操作建议用`assigh`， `resize`会出问题，它适用于长度变化的情况，不变就初始化不了

## 代码：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int Max = 5005;
vector&lt;vector&lt;int&gt;&gt; g(Max, vector&lt;int&gt; (Max));
vector&lt;int&gt; f;
void solution() {
    f.resize(Max, Max);
    int n; cin &gt;&gt; n;
    vector&lt;int&gt; a(n);
    //同时记录所有数的最大公约数
    int sg = 0;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
        sg = g[sg][a[i]];
    }
    //获得sg的最小操作数查找
    //将所有数组元素改为sg的倍数的同时记录sg的最大倍数
    int m = 0;
    for(int i = 0; i &lt; n; i++) {
        a[i] /= sg;
        m = max(m, a[i]);
        f[a[i]] = 0;
    }
    for(int x = m; x &gt; 0; x--) for(int j = 0; j &lt; n; j++) {
        int y = a[j];
        f[g[x][y]] = min(f[g[x][y]], f[x] + 1);
    }
    //这里的两个max分别对应找出的sg和本就存在的sg，警醒自己对不同的情况一定要仔细进行讨论代码的具体实现
    int res = max(f[1] - 1, 0);
    for(int i = 0; i &lt; n; i++) {
        if(a[i] != 1) res++;
    }
    cout &lt;&lt; res &lt;&lt; endl;
    f.clear();
}

int main() {
    for(int i = 0; i &lt; Max; i++) g[i][0] = g[0][i] = g[i][i] = i;
    for(int i = 1; i &lt; Max; i++) for(int j = 1; j &lt; i; j++) g[i][j] = g[j][i] = g[j][i % j];
    int t; cin &gt;&gt; t;
    while(t--) solution();
    return 0;
} 
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/tong-guo-qu-zui-da-gong-yue-shu-qu-de-shi-shu-zu-yuan-su-xiang-tong-de-zui-kuai-bu-shu.html</guid><pubDate>Sat, 07 Jun 2025 07:07:02 +0000</pubDate></item><item><title>双数组局部以2为底交叉位置幂最大和</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shuang-shu-zu-ju-bu-yi-2-wei-di-jiao-cha-wei-zhi-mi-zui-da-he.html</link><description>[[跳转题目](https://codeforces.com/contest/2116/problem/B)](https://codeforces.com/contest/2116/problem/B)

## 题目大意：

&gt; 给定了两个长度为`n`的全排列数组，
&gt;
&gt; 通过以下方法计算一个数组 r₀, r₁, …, rₙ₋₁ ：
&gt;
&gt; - 在数组一中取`i`位置元素，就在数组二中取`n - i`位置的元素，得出`pow(2, 选定元素)`之和
&gt; - 在`r`中的下标就是当前位置`i`的范围，r₀就是`i`只能取`0`， rₙ₋₁就是`i`最多取到`n - 1`处的元素
&gt;
&gt; 要求输出`r`数组，较大的结果要输出模998244353的结果

## 思路：

- 有幂运算，可以先预处理出一个数组，下标表示幂数，存储幂运算的值
- 显然结果和幂数有关，可以用来简化比较过程，两个数组进行一次遍历记录过程中的最大值就可以了

## 问题：

- **&lt;u&gt;对大数据的模运算在哪里模？&lt;/u&gt;**

  1. 存放幂运算的值时
  2. 两个数组的幂运算值加和时
- **&lt;u&gt;模运算需要注意什么？&lt;/u&gt;**

  - 不能进行大小比较

    ```cpp
    //问题写法：
    cout &lt;&lt; max((s[p[i]] + s[q[k - i]]), s[q[j]] + s[p[k - j]]) % Mod &lt;&lt; ' \n'[k == n - 1];
    //正确写法：
    cout &lt;&lt; (s[p[i]] + s[max(p[k - j], q[k - i])]) % Mod &lt;&lt; ' \n'[k == n - 1];
    ```

## 代码：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
const long long Mod = 998244353;
const int Max = 1e5 + 10;
vector&lt;long long&gt; s(Max);
void solution() {
    int n; cin &gt;&gt; n;
    vector&lt;int&gt; p(n), q(n);
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; p[i];
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; q[i];
    for(int i = 0, j = 0, k = 0; k &lt; n; k++) {
        if(p[i] &lt; p[k]) i = k;
        if(q[j] &lt; q[k]) j = k;
        if(p[i] &gt; q[j]) {
            cout &lt;&lt; (s[p[i]] + s[q[k - i]]) % Mod &lt;&lt; ' \n'[k == n - 1];
        } else if(p[i] &lt; q[j]){
            cout &lt;&lt; (s[q[j]] + s[p[k - j]]) % Mod &lt;&lt; ' \n'[k == n - 1];
        } else {
            //问题写法：
            cout &lt;&lt; max((s[p[i]] + s[q[k - i]]), s[q[j]] + s[p[k - j]]) % Mod &lt;&lt; ' \n'[k == n - 1];
            //正确写法：
            cout &lt;&lt; (s[p[i]] + s[max(p[k - j], q[k - i])]) % Mod &lt;&lt; ' \n'[k == n - 1];
        }
    }
}
int main() {
    // ios::sync_with_stdio(0); cin.tie(0);
    s[0] = 1; 
    for(int i = 1; i &lt; Max; i++) {
        s[i] = 2 * s[i - 1] % Mod;
    }
    int t; cin &gt;&gt; t;
    while(t--) solution();
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shuang-shu-zu-ju-bu-yi-2-wei-di-jiao-cha-wei-zhi-mi-zui-da-he.html</guid><pubDate>Thu, 05 Jun 2025 12:22:26 +0000</pubDate></item><item><title>将斐波那契方块放入盒子</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/jiang-fei-bo-na-qi-fang-kuai-fang-ru-he-zi.html</link><description>[[跳转题目](https://codeforces.com/contest/2111/problem/B)](https://codeforces.com/contest/2111/problem/B)

## 题目大意:

&gt; 给定`n`个正方形，边长构成以1、2为开始的斐波那契数列，给定长宽高确定的盒子，问是否能装下所有的`n`个方块

## 思路：

1. 由边的数学关系可知，只要能放下前两个块，剩下的块都可以直接放下

## 代码：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
void solution() {
    int n, m; cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; ms(m, vector&lt;int&gt; (3));
    for(int i = 0; i &lt; m; i++) {
        int w, l, h;
        cin &gt;&gt; w &gt;&gt; l &gt;&gt; h;
        ms[i][0] = w;
        ms[i][1] = l;
        ms[i][2] = h;
    }
    vector&lt;bool&gt; res(m, 0);

    auto check = [&amp;] (int a, int b, int h, vector&lt;int&gt; &amp;rec) {
        int aa = rec[n];
        int a1 = a - aa;
        int b1 = b - aa;
        if(a1 &gt;= 0 &amp;&amp; b1 &gt;= 0 &amp;&amp; h &gt;= aa) {
            if(n == 1)
                return 1;
            else if(n &gt; 1 &amp;&amp; rec[n - 1] &lt;= max(a1, b1)) {
                return 1;
            } else if(n &gt; 1 &amp;&amp; rec[n - 1] &lt;= h - rec[n]) {
                return 1;
            } else return 0;
        } else return 0;
    };

    vector&lt;int&gt; rec(n + 1);
    rec[1] = 1; rec[2] = 2;
    for(int i = 3; i &lt;= n; i++) {
        rec[i] = rec[i - 1] + rec[i - 2];
    }

    for(int i = 0; i &lt; m; i++) {
        //暴力三种底边情况
        res[i] = check(ms[i][0], ms[i][1], ms[i][2], rec) || check(ms[i][0], ms[i][2], ms[i][1], rec) || check(ms[i][1], ms[i][2], ms[i][0], rec);
    }
    for(int i = 0; i &lt; m; i++) {
        cout &lt;&lt; res[i];
    }
    cout &lt;&lt; endl;
}

int main() {
    int t; cin &gt;&gt; t;
    while(t--) solution();
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/jiang-fei-bo-na-qi-fang-kuai-fang-ru-he-zi.html</guid><pubDate>Wed, 04 Jun 2025 08:12:51 +0000</pubDate></item><item><title>数组选定元素按位异或和的最大值</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-xuan-ding-yuan-su-an-wei-yi-huo-he-de-zui-da-zhi.html</link><description>[跳转题目](https://codeforces.com/contest/2094/problem/E)
## 题目大意：

&gt; 给定一个数组，数组长度为`n`，所有的元素不可能超过`n`，从数组中选定一个元素与所有的其他元素进行按位异或并加和，求这个和的最大值

## 思路：

1. 如果直接对所有元素进行按位异或并求和的操作复杂度太高，为O（n^2)
2. 通过一番思考知道没有捷径可以直接找出那个能得出最大结果的值，所以过程肯定涉及暴力枚举，接下来要对复杂度进行优化
3. 题目给定范围为`n &lt; 2 ^ 30`，所以可以用一个空间为31的数组记录不同位上1的个数，那么之后的复杂度可以消减为O（30n）
## 代码：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
void solution() {
    int n; cin &gt;&gt; n;
    //分别记录二进制1相同位置1的数量和原数据
    vector&lt;int&gt; cnts(31, 0), a(n);

    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
        for(int j = 0; j &lt; 31; j++) {
            if((a[i] &gt;&gt; j) &amp; 1) cnts[j]++;
        }
    }

    long long res = 0;
    //暴力遍历所有的数据取最大值
    for(int i = 0; i &lt; n; i++) {
        int num = a[i];
        long long sum = 0;
        for(int j = 0; j &lt; 31; j++) {
            bool tmp = (num &gt;&gt; j) &amp; 1;
            if(tmp) sum += (n - cnts[j]) * pow(2, j);
            else sum += (cnts[j]) * pow(2, j);
        }
        res = max(res, sum);
    }

    cout &lt;&lt; res &lt;&lt; endl;
}

int main() {
    int t; cin &gt;&gt; t;
    while(t--) solution();
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-xuan-ding-yuan-su-an-wei-yi-huo-he-de-zui-da-zhi.html</guid><pubDate>Wed, 04 Jun 2025 08:03:57 +0000</pubDate></item><item><title>2025/6/1周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-6-1-zhou-ji.html</link><description>感觉校队悬了，一看他们全都是蓝二，这下看懂了，我不该选Java方向的，暴力比C++要求高的多，语言效率太低了，当时手撕最小生成树竟然结果的输出没来及改，要是校队卡我简历那我没什么好说的了

还是难好好复习，即使是期末月了，我怕我不能今年进校队会后悔一辈子。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-6-1-zhou-ji.html</guid><pubDate>Sun, 01 Jun 2025 14:48:47 +0000</pubDate></item><item><title>通过删除元素与调整元素构造最大公约数为1的数组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/tong-guo-shan-chu-yuan-su-yu-diao-zheng-yuan-su-gou-zao-zui-da-gong-yue-shu-wei-1-de-shu-zu.html</link><description>跳转题目-&gt;[[D - Array and GCD](https://codeforces.com/contest/2104/problem/D)](https://codeforces.com/contest/2104/problem/D)

## 题目大意:

&gt; 给定一个数组，有以下定义：
&gt;
&gt; 1. 每个元素最小是2
&gt; 2. 对于任意数组中的元素都满足最大公约数为1
&gt;
&gt; 这样的数组叫做完美数组，
&gt;
&gt; 现在可以对数组任意进行如下操作：
&gt;
&gt; 1. 初始有0个金币
&gt; 2. 将一个数减少多少就获得多少个金币
&gt; 3. 可以花费金币将数字等个数增大
&gt;
&gt; 如果以上操作无法使得数组变成完美数组，可以删除任意元素，最终输出的结果就是可以将数组转化为完美数组的最小删除数

## 思路：

1. 从任意操作中看出：数组的总和不能增大，只能减小（这一点我都没能想到😓）
2. 因为任意元素最大公约数是1，所以所有的数都应该是素数，由条件1可知，数组的总和可以减小，也就是说可以通过判断当前数组长度下数组总和是否大于等于等个数的素数的总和
3. 在一定范围内的素数的快速寻找可以用埃拉托斯特尼筛法，再由题目给定的数组长度范围为`4e5`，根据**质数分布与质数定理**，$p_{k}\approx k\cdot\ln k$，求出约等于`6e6`（向上取整）求得数组长度对应的相同数量的素数
4. 删除操作应从最小值开始删，因为数组和在元素数量一定时要尽量大

## 代码：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int span = 6000000;
vector&lt;long long&gt; prime;

void solution() {
    int n; cin &gt;&gt; n;
    vector&lt;int&gt; a(n);
    long long sum = 0;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
        sum += a[i];
    }
    sort(a.begin(), a.end());
    if(sum &gt;= prime[n - 1]) {
        cout &lt;&lt; 0 &lt;&lt; endl;
        return;
    }

    for(int i = 0; i &lt; n; i++) {
        sum -= a[i];
        if(sum &gt;= prime[n - i - 2]) {
            cout &lt;&lt; i + 1 &lt;&lt; endl;
            return;
        }
    }
}
int main() {
    vector&lt;bool&gt; p(span, 1);
    for(int i = 2; i &lt; span; i++) {
        if(!p[i]) continue;
        if(!prime.size()) {
            prime.push_back(i);
        }else
            prime.push_back(i + prime.back());
        for(int j = i; j &lt; span; j+= i) {
            p[j] = 0;
        }
    }
    int t; cin &gt;&gt; t;
    while(t--) solution();
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/tong-guo-shan-chu-yuan-su-yu-diao-zheng-yuan-su-gou-zao-zui-da-gong-yue-shu-wei-1-de-shu-zu.html</guid><pubDate>Sun, 01 Jun 2025 14:35:04 +0000</pubDate></item><item><title>素数章节</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/su-shu-zhang-jie.html</link><description># 质数
## **质数分布与质数定理**

质数定理（Prime Number Theorem, PNT）描述了质数在自然数中的分布密度：当自然数 $n$ 足够大时，不超过 $n$ 的质数个数 $\pi(n)$ 近似为 $\frac{n}{\ln n}$。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/su-shu-zhang-jie.html</guid><pubDate>Sun, 01 Jun 2025 08:38:46 +0000</pubDate></item><item><title>排序构造缺失元素的非负临项差数组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/pai-xu-gou-zao-que-shi-yuan-su-de-fei-fu-lin-xiang-cha-shu-zu.html</link><description>https://codeforces.com/contest/2077/problem/A——题目链接
## 题目大意:

&gt; 给定一个长度为`2 * n`的数组，其顺序已经被打乱，并且缺失了一个数字，在顺序没有打乱且没有数字确实的情况下满足以下条件：
&gt;
&gt; 1. 没有相同的数字
&gt; 2. `a1 = a2 - a3 + a4 - a5 + ...... + a(2*n) - a(2*n-1)`
&gt; 3. 所有数字都是大于`1`的整数
&gt;
&gt; 要求按照已知的数字来构造一个符合条件的数组

## 思路：

- 可以根据条件2来构造这个数字，这个数字要符合没有相同数字的要求，为使过程尽量最简单，可以通过数学表达式构造比最大数大或比最小值小的数进行补位
- 肯定要对式子进行排序了，有这个想法了，常见的就有两种：

  1. 从大到小
  2. 从小到大

  本题不能存在负数，且有减法，直接从大到小秒了
- 对条件2进行变形，想办法构造出最值，以此来避免重复

  `a2 = a1 + (s3 - a4) + (a5 - a6) + ......(a2*n-1 - a2*n) + a2*n+1`

  这里的`a1`就是那个已知的数组的最大值，`a2`就是要构造出的比最大值还大的值，输出结果时记得在第二位输出它就可以了

## 代码：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
void solution() {
    int n; cin &gt;&gt; n;
    vector&lt;int&gt; res(2 * n + 1);
    for(int i = 0; i &lt; 2 * n; i++) {
        cin &gt;&gt; res[i + 1];
    }
    sort(res.begin() + 1, res.end(), [](int a, int b) {return a &gt; b;});
    int ans = res[1] + res[2 * n];
    for(int i = 2; i &lt; 2 * n - 1; i += 2) {
        ans += res[i] - res[i + 1];
    }

    cout &lt;&lt; res[1] &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; ' ';
    for(int i = 2; i&lt; 2 * n + 1; i++) {
        cout &lt;&lt; res[i] &lt;&lt; ' \n'[i == 2 * n];
    }
}

signed main() {
    int t; cin &gt;&gt; t;
    while(t--) solution();
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/pai-xu-gou-zao-que-shi-yuan-su-de-fei-fu-lin-xiang-cha-shu-zu.html</guid><pubDate>Sat, 31 May 2025 13:51:52 +0000</pubDate></item><item><title>Codeforces Round 1027 (Div. 3)完成题目回顾</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/Codeforces%20Round%201027%20%28Div.%203%29-wan-cheng-ti-mu-hui-gu.html</link><description>[[Codeforces Round 1027 (Div. 3)](https://codeforces.com/contest/2114)](https://codeforces.com/contest/2114)完成题目回顾

## A.

### 需要注意的问题：

1. #### 除零错误

    除数不确定时一定要考虑这个数有没有可能变化成0，对此要进行提前特殊处理
2. #### 开方后整形精度丢失

    判断`sqrt(x) * sqrt(x) == x`防止精度丢失造成的影响

## C.

一个典型的数组条件元素剔除的题目，双指针过程还是要多手动模拟一下快指针到达边际后慢指针与是否满足条件的检查处理，调试代码可以把过程存储在`vector`中做日志，在问题出现时方便溯源。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/Codeforces%20Round%201027%20%28Div.%203%29-wan-cheng-ti-mu-hui-gu.html</guid><pubDate>Fri, 30 May 2025 10:21:56 +0000</pubDate></item><item><title>移除一个点位后覆盖所有坐标的最小面积</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/yi-chu-yi-ge-dian-wei-hou-fu-gai-suo-you-zuo-biao-de-zui-xiao-mian-ji.html</link><description>## 题目大意：

&gt; 在一个图（大小确定）中，给定`n`个坐标，要求可以移动一个坐标，输出能覆盖这些坐标的最小面积

## 思路：

1. 覆盖面积等于`(maxx - minx + 1) * (maxy - miny + 1)`，那么就可以对最值做文章，只移动一个点，那么取值不是第一个最值就是第二个最值
2. 记录两个最值，遍历所有的坐标尝试将其剔除：将坐标与最值比较，若等于最值，就取第二个最值，具体过程通过绘图模拟感受，圈住的是要剔除的点。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/yi-chu-yi-ge-dian-wei-hou-fu-gai-suo-you-zuo-biao-de-zui-xiao-mian-ji.html</guid><pubDate>Fri, 30 May 2025 10:07:45 +0000</pubDate></item><item><title>为二分搜索准备的最小排序数（模拟神题）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/wei-er-fen-sou-suo-zhun-bei-de-zui-xiao-pai-xu-shu-%EF%BC%88-mo-ni-shen-ti-%EF%BC%89.html</link><description>## 题目大意：

&gt; 长度为`n`的全排列，对其进行二分搜索，给定搜索的左右边界`l、r`和目标值`k`。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/wei-er-fen-sou-suo-zhun-bei-de-zui-xiao-pai-xu-shu-%EF%BC%88-mo-ni-shen-ti-%EF%BC%89.html</guid><pubDate>Wed, 28 May 2025 13:10:28 +0000</pubDate></item><item><title>2025/5/25周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-25-zhou-ji.html</link><description>## 决策：

1. 早晨起来跑步、锻炼
2. 晚上没有事就十点睡觉
3. 打游戏尽量插空打了
4. 期末月了，复习吧孩子！

## 如何实现：

一个月满二十天就同意自己给游戏充小月卡。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-25-zhou-ji.html</guid><pubDate>Sun, 25 May 2025 12:43:19 +0000</pubDate></item><item><title>D - Fewer Batteries（最超模（</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/D%20-%20Fewer%20Batteries%EF%BC%88-zui-chao-mo-%EF%BC%88.html</link><description>## 思路：

- 本题的目的是找到所有可达路径中最大边权的最小值，已知的图论算法都无法完成这个任务，这个最小的最大值属实诡异
- 但是可以在道路的可达性上下手，比如找到了一个路径，他的边权最大值是max，我们只知道这是一条通路的一个答案，其他通路没有有效的方式查找。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/D%20-%20Fewer%20Batteries%EF%BC%88-zui-chao-mo-%EF%BC%88.html</guid><pubDate>Sun, 25 May 2025 12:35:33 +0000</pubDate></item><item><title>Codeforces Round 1026 (Div. 2) Editorial 完成题目回顾</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/Codeforces%20Round%201026%20%28Div.%202%29%20Editorial%20-wan-cheng-ti-mu-hui-gu.html</link><description>[Codeforces Round 1026 (Div. 2)](https://codeforces.com/blog/entry/143186) 
## A

涉及奇偶性，问最小值和最大值之和是偶数所需的最小操作次数，那就分别找排序以后和左边奇偶性不同的值的位置和右边奇偶性不同的位置。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/Codeforces%20Round%201026%20%28Div.%202%29%20Editorial%20-wan-cheng-ti-mu-hui-gu.html</guid><pubDate>Sun, 25 May 2025 09:30:33 +0000</pubDate></item><item><title>子数组的有序价值</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zi-shu-zu-de-you-xu-jia-zhi.html</link><description>## 题目概述：

&gt; 给定一个数组，输入数组的长度和要分成的偶数个子数组个数（k），偶数索引的子数组组成一个新的数组，定义这个数组从头开始的第i个元素与i不同则i是该数组的value，求这个数组的最小value

## 存在的问题：

- 有些犯懒了，对子数组最大长度没有清晰的辨析。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zi-shu-zu-de-you-xu-jia-zhi.html</guid><pubDate>Fri, 23 May 2025 13:48:52 +0000</pubDate></item><item><title>手套配对（贪心算法魅力时刻，已破防</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shou-tao-pei-dui-%EF%BC%88-tan-xin-suan-fa-mei-li-shi-ke-%EF%BC%8C-yi-po-fang.html</link><description>## 题目大意：

&gt; 抽屉中共有`n`种颜色的手套，左右手的手套由`l`、`r`两个数组存储，数组的下标就是其颜色。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shou-tao-pei-dui-%EF%BC%88-tan-xin-suan-fa-mei-li-shi-ke-%EF%BC%8C-yi-po-fang.html</guid><pubDate>Wed, 21 May 2025 14:13:04 +0000</pubDate></item><item><title>二进制字符串”打印费用“</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/er-jin-zhi-zi-fu-chuan-%E2%80%9D-da-yin-fei-yong-%E2%80%9C.html</link><description>## 题目大意：

&gt; 一个二进制字符串，每打印一次记为一次操作，切换打印零还是一也算一次操作，其实位置为0不需要进行切换，要求对字符串进行最多一次字串的反转，得到操作数最小的新字符串

## 思路：

1. 显然操作数 = 字符串长度 + 切换次数 + 1（如果起始位置为‘1’）
2. 所有的字符都可以在最前方加字符0，以实现所有字符串计算的一视同仁
3. 对字符串进行翻转时可以减少操作数，**其原理是**改变前后的“切换关系”，不需要切换，就少一次，那么最多少两次操作
4. 思考这里的两次操作是否通用，即继续思考原理：

    1. 当切换次数达到三次及以上时一定能减少两次操作，因为这时一定能保证找到一个字串使其前后交换以后前后都减少一次操作次数
    2. 切换次数为2时可以减少一次
    3. 切换次数小于等于1次不能减少

## 代码：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
void testCase() {
    string s;
    int n;
    cin &gt;&gt; n;
    cin &gt;&gt; s;
    s='0'+s;
    int ans = 0, cur = s[0];
    for (int i = 1; i &lt;= n; i++) {
        int dig = s[i];
        if (cur != dig) 
           ans++;
        cur = dig;
    }
   if(ans&gt;=3)
     cout&lt;&lt; ans-2 + n&lt;&lt;'\n';
   else if(ans==2)
     cout&lt;&lt; ans-1 + n&lt;&lt;'\n';
   else 
     cout&lt;&lt;ans+n&lt;&lt;'\n';
}
int main(){
    int t;
    cin&gt;&gt;t;
    while(t--)
        testCase();
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/er-jin-zhi-zi-fu-chuan-%E2%80%9D-da-yin-fei-yong-%E2%80%9C.html</guid><pubDate>Wed, 21 May 2025 01:02:12 +0000</pubDate></item><item><title>等权图给定移动数集合下的可达性</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/deng-quan-tu-gei-ding-yi-dong-shu-ji-he-xia-de-ke-da-xing.html</link><description>&lt;html&gt;
&lt;body&gt;
&lt;!--StartFragment--&gt;&lt;h2 id='题目大意-' updated='20250520164130'&gt;题目大意：&lt;/h2&gt;
&lt;blockquote id='20250520164131-2bik7e6' updated='20250520164132'&gt;
&lt;p id='20250520164132-j4g36en' updated='20250520165259'&gt;给定一个有n个点、m条边的图，给一个移动次数的集合，要求能在集合中选择并移除一个数后从起点1开始经过相应条边，要求结果输出每个顶点是否能到达，能输出1，不能输出0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id='思路-' updated='20250520165304'&gt;思路:&lt;/h2&gt;
&lt;ol id='20250520165306-x8vrisv' updated='20250520165308'&gt;
&lt;li id='20250520165308-0jnj638' updated='20250520165308'&gt;只需要求起始点到目标点的最短距离，只要集合中的移动数总和或次小的移动数总和大于这个奇偶性相同的最短距离就可以到达&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id='注意-' updated='20250520165622'&gt;注意：&lt;/h2&gt;
&lt;ol id='20250520165624-7j11bbp' updated='20250520165625'&gt;
&lt;li id='20250520165625-rcayeb9' updated='20250520165625'&gt;因为本解过程有奇偶的要求，可以想到移动次数只有一个的时候不能估计两种奇偶性，但是点在有环的情况下可能会有奇偶分别的两种最短路，这就导致有可能产生疏漏，因此用二维数组存储奇偶两个最短距离&lt;/li&gt;
&lt;li id='20250520165922-zhvt2yh' updated='20250520165922'&gt;本题明显是等权图，所以如下图所示使用BFS效率更高&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id='BFS-与-Dijkstra-算法的效率对比' updated='20250520164107'&gt;BFS 与 Dijkstra 算法的效率对比&lt;/h3&gt;

维度 | 广度优先搜索（BFS） | Dijkstra 算法
-- | -- | --
图类型 | 仅适用于无权图或等权图 | 适用于非负权图（边权≥0）
最短路径定义 | 顶点间的最少边数（步数） | 顶点间的最小权值和
时间复杂度 | O(V + E)（V为顶点数，E为边数） | 取决于实现方式：- 普通数组：O(V^2)- 优先队列：O((V+E)log V）
空间复杂度 | O(V)（队列存储顶点） | O(V)（存储距离和优先队列）
效率对比 | 在无权图中效率更高，无需处理权值 | 在非负权图中不可替代，但需处理权值


&lt;pre&gt;&lt;code class='language-cpp'&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

vector&amp;lt;int&amp;gt; minDist;
class mycomparison {
public:
    bool operator() (const int&amp;amp; a1, const int&amp;amp; a2) const {
        return minDist[a1] &amp;gt; minDist[a2];
    }
};

void solution() {

    int n, m, l, s, e;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; l;
    //不用记录具体每一个数字，只需总和和最小的奇数（可以改变奇偶并且尽量不让改变奇偶后的值太小）
    int sum = 0, minOdd = INT_MAX;
    for(int i = 0; i &amp;lt; l; i++) {
        int x; cin &amp;gt;&amp;gt; x;
        if(x &amp;amp; 1) {
            minOdd = min(minOdd, x);
        }
        sum += x;
    }

    vector&amp;lt;list&amp;lt;int&amp;gt;&amp;gt; grid(n + 1);
    for(int i = 0; i &amp;lt; m; i++) {
        cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; e;
        grid[s].push_back(e);
        grid[e].push_back(s);
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; minDist(n + 1, vector&amp;lt;int&amp;gt; (2, INT_MAX));
    minDist[1][0] = 0;
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;
    q.push({1, 0});
    
    while(!q.empty()) {
        pair&amp;lt;int, int&amp;gt; cur = q.front(); q.pop();
        for(int nextNode : grid[cur.first]) {
            if(minDist[nextNode][!cur.second] &amp;gt; minDist[cur.first][cur.second] + 1) {
                minDist[nextNode][!cur.second] = minDist[cur.first][cur.second] + 1;
                q.push({nextNode, !cur.second});
            }
        }
    }

    for(int i = 1; i &amp;lt;= n; i++) {
        bool found = 0;
        for(int p = 0; p &amp;lt; 2; p++) {
            int s = sum - (p == sum % 2? 0:minOdd);
            if(s &amp;gt;= minDist[i][p]) found = 1;
        }
        cout &amp;lt;&amp;lt; found;
    }
    cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
}

int main() {
    int t; cin &amp;gt;&amp;gt; t;
    while(t--) solution();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--EndFragment--&gt;
&lt;/body&gt;
&lt;/html&gt;。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/deng-quan-tu-gei-ding-yi-dong-shu-ji-he-xia-de-ke-da-xing.html</guid><pubDate>Tue, 20 May 2025 10:24:06 +0000</pubDate></item><item><title>2025/5/18周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-18-zhou-ji.html</link><description>**好的节奏，应该从早睡早起开始**，一天的开始至少对我自己来说重要性是无需多言的。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-18-zhou-ji.html</guid><pubDate>Sun, 18 May 2025 14:03:06 +0000</pubDate></item><item><title>猜数？展示交互神力！（bushi</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/cai-shu-%EF%BC%9F-zhan-shi-jiao-hu-shen-li-%EF%BC%81%EF%BC%88bushi.html</link><description>## 题目大意概述：

&gt; 给定一个未知数`x(0&lt;=x&lt;=1e9)`， 本题作为一道交互题有如下的交互过程：
&gt;
&gt; - 'add ' Add some integer  `y` to .The jury will output '1' if  is within `[1, 1e18]` (successful), and '0' otherwise. If successful, update `x = x + y`
&gt; - 'mul ' Multiply  by a positive integer  `y`.The jury will output '1' if  is within `[1, 1e18]` (successful), and '0' otherwise. If successful, update `x = x * y`
&gt; - 'div ' Divide  by a positive integer  `y`.The jury will output '1' if  is a divisor of `[1, 1e18]` (successful), and '0' otherwise. If successful, update `x = x / y`
&gt; - 'digit' Make  equal to the sum of its digits.The jury will always output '1' and update `x = S(x)`（x的每一位数字之和：如S（123）= 1 + 2 + 3 = 6。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/cai-shu-%EF%BC%9F-zhan-shi-jiao-hu-shen-li-%EF%BC%81%EF%BC%88bushi.html</guid><pubDate>Sun, 18 May 2025 13:57:54 +0000</pubDate></item><item><title>方块切割博弈（博弈但不是博弈？🤣）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/fang-kuai-qie-ge-bo-yi-%EF%BC%88-bo-yi-dan-bu-shi-bo-yi-%EF%BC%9F%F0%9F%A4%A3%EF%BC%89.html</link><description>## 题目大意：

&gt; 给定一个`n * m`格子的图，和一个位置在`(a,b)`格子处的一个标记，现在有两名玩家进行操作，直到该图只剩一个格子
&gt;
&gt; 1. 第一名玩家先进行切割，没有标记的部分将消失，他会尽力使切割的次数尽量少
&gt; 2. 第二名玩家调整标记的位置，他会尽力使切割的次数尽量多
&gt;
&gt; 预测给定的样例需要切割几刀结束

## 思路：

1. 切割分为两个阶段，初始阶段和被第二名玩家移动后的切割阶段。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/fang-kuai-qie-ge-bo-yi-%EF%BC%88-bo-yi-dan-bu-shi-bo-yi-%EF%BC%9F%F0%9F%A4%A3%EF%BC%89.html</guid><pubDate>Sun, 18 May 2025 02:58:32 +0000</pubDate></item><item><title>Floyd多源最短路</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/Floyd-duo-yuan-zui-duan-lu.html</link><description>## 核心思想：

- 动态规划

## 思路：

- 按照动态规划的基本步骤:

  1. 确定dp数组及其下标的意义：`grid[i][j][k] = m`，表示 节点`i`到 节点`j`以`[1...k]`集合中的一个节点为中间节点的最短距离为`m`。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/Floyd-duo-yuan-zui-duan-lu.html</guid><pubDate>Sat, 17 May 2025 14:15:28 +0000</pubDate></item><item><title>数组双端切割</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-shuang-duan-qie-ge.html</link><description>## 题目大意：

&gt; 给定长度为`n`的非零数组，取数组中的任意一个下标，进行以下操作：
&gt;
&gt; 1. 正数，切割掉包括当前数和前面的所有元素，并获得当前数个硬币
&gt; 2. 负数，切割掉包括当前数和后面的所有元素，并获得当前数个硬币w
&gt;
&gt; 问怎样操作使数组为空时硬币数量最多？

## 思路：

1. 最基础的想法，切割最左端的正数或者最右侧的负数就可以尽量提高切割的次数来提高硬币总数
2. 但是显然有根本不满足以上想法的情况，这时就会出现，切割一个左侧的正数，这个正数的左侧的所有负数都没了，如果切割这些负数比切割这个正数有更高的收益呢？这时就想到了统计前缀和，统计从左侧开始切割获得的正数大小，统计从右侧开始获得的负数大小
3. 此时左右侧正、负数分别相加（切割一个位置左侧的正数、右侧的负数）就是答案了


## 代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int t;
    cin &gt;&gt; t;
    while(t--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;int&gt; a(n + 1);
        for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
        vector&lt;long long&gt; preP(n + 1);preP[0] = 0;//正序遍历存储+数前缀和
        vector&lt;long long&gt; revN(n + 2);revN[n + 1] = 0;//逆序遍历存储-数前缀和

        for(int i = 1; i &lt;= n; i++) {
            if(a[i] &gt; 0) {
                preP[i] = a[i] + preP[i - 1];
            } else {
                preP[i] = preP[i - 1];
            }
        }
        for(int i = n; i &gt;= 1; i--) {
            if(a[i] &lt; 0) {
                revN[i] = abs(a[i]) + revN[i + 1];
            } else {
                revN[i] = revN[i + 1];
            }
        }

        long long res = 0;
        for(int i = 1; i &lt;= n; i++) {
            res = max(res, preP[i] + revN[i]);
        }
        cout &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-shuang-duan-qie-ge.html</guid><pubDate>Fri, 16 May 2025 14:05:40 +0000</pubDate></item><item><title>单源有限最短路</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/dan-yuan-you-xian-zui-duan-lu.html</link><description>## 思路

* 要获得起源到终点相隔不多于`k`个节点的最短路径，可以想到`n`次松弛找到`n`条边的最短路径，那就松弛`k + 1`次
* 对于负权回路结果并不理想，原因是受边的顺序的影响，有可能1次就能松弛很多节点，再受负权回路影响会使期望变小，解决方法是防止这种现象的出现，即要确保`&lt;n`次松弛不能得到`n`条边的最短路径，就需要记录上一个`minDist`，参照上一个来调整当前的节点。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/dan-yuan-you-xian-zui-duan-lu.html</guid><pubDate>Thu, 15 May 2025 07:36:30 +0000</pubDate></item><item><title>四重交换（应用树状数组）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/si-zhong-jiao-huan-%EF%BC%88-ying-yong-shu-zhuang-shu-zu-%EF%BC%89.html</link><description>### 题目大意：

&gt; 给定一个长度为`n`的全排列数组，可以进行的操作是：选定位置`i`，`swap(a[i], a[i + 2]);swap(a[i + 1], a[i + 3]);`要求经过一定的操作以后输出字典序最小的数组

### 解析：

1. 由于交换是隔一位进行交换，所以无论怎么交换奇偶性都不变，因此考虑对奇偶位置的元素进行分开处理
2. 要获得字典序最小的数组需要小的尽量在最前边，要保证四位进行一次交换，就把当前位置换成索引奇偶性相同的依次递增的元素（索引越小元素就选择小），不用考虑操作的次数，因此依次对每一位都进行操作，依次确定了每一位的符合条件的最小的数。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/si-zhong-jiao-huan-%EF%BC%88-ying-yong-shu-zhuang-shu-zu-%EF%BC%89.html</guid><pubDate>Wed, 14 May 2025 13:31:50 +0000</pubDate></item><item><title>树状数组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zhuang-shu-zu.html</link><description>**树状数组**（Binary Indexed Tree，BIT），也被叫做 Fenwick Tree，是一种能够**高效处理区间查询与单点更新问题的数据结构**。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zhuang-shu-zu.html</guid><pubDate>Wed, 14 May 2025 08:58:35 +0000</pubDate></item><item><title>操作符重载</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/cao-zuo-fu-zhong-zai.html</link><description>&lt;html&gt;
&lt;body&gt;
&lt;!--StartFragment--&gt;&lt;p id='20250512165959-3vsjxig' updated='20250512165959'&gt;在C++中，操作符重载允许你为自定义类型重新定义运算符的行为，使得这些运算符可以用于自定义类型的对象。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/cao-zuo-fu-zhong-zai.html</guid><pubDate>Tue, 13 May 2025 16:33:39 +0000</pubDate></item><item><title>SPFA（Bellman_ford队列优化）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/SPFA%EF%BC%88Bellman_ford-dui-lie-you-hua-%EF%BC%89.html</link><description>## 解析：

1. 相对于普通版优化掉了被`if(!minDist[start])`排除的无效松弛

    * 通过队列存储可以对周围进行有效松弛的点
2. 为什么队列中不能同时存在一个点但是队列中可以多次存在一个点？

    * 有可能先接触到的点的最短距离还可以进行松弛，那么之后的点位都需要继续进行松弛，通过队列的形式也恰巧可以再次发散松弛后续节点并排除已松弛到最佳的节点

## 注意：

* `queue`容器要使用`front()`
* `top()`函数用于`stack`\\`priority_queue`容器
* 依然对每个遍历到的点都要进行`minDist`最短距离的刷新
* 只在队列是否要插入点时判断点是否已经在队列中

## 优化 检查负权回路：

* 记录点进入队列的次数就相当于记录了松弛的次数

## 代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int n, m, s, e, val;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; grid(n + 1);
    for(int i = 0; i &lt; m; i++) {
        cin &gt;&gt; s &gt;&gt; e &gt;&gt; val;
        grid[s].push_back({e, val});
    }
    
    vector&lt;int&gt; minDist(n + 1, INT_MAX);
    vector&lt;int&gt; inQueue(n + 1, false);//记录已经在队列中的元素
    minDist[1] = 0;
    queue&lt;int&gt; q;
    q.push(1);
    inQueue[1] = true;
    vector&lt;int&gt; count(n + 1, 0);//记录节点加入队列的次数
    bool flag = false;//记录是否存在负权回路
    
    while (!q.empty())
    {
        int cur = q.front();
        q.pop();
        inQueue[cur] = false;
        for(pair&lt;int, int&gt; edge:grid[cur]) {
            int to = edge.first;
            int val = edge.second;
            if(val + minDist[cur] &lt; minDist[to]) {
                minDist[to] = val + minDist[cur];
                //已经在队列中不用重复添加
                if(!inQueue[to]) {
                    inQueue[to] = true;
                    q.push(to);
                    count[to]++;
                    if(count[to] == n) {//松弛超过n - 1次
                        flag = true;
                        while(!q.empty()) q.pop();
                        break;
                    }
                }
            }
        }
    }
    
    if(flag) cout &lt;&lt; 'circle' &lt;&lt; endl;
    else
        minDist[n] == INT_MAX? cout &lt;&lt; 'unconnected' &lt;&lt; endl: cout &lt;&lt; minDist[n] &lt;&lt; endl;
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/SPFA%EF%BC%88Bellman_ford-dui-lie-you-hua-%EF%BC%89.html</guid><pubDate>Tue, 13 May 2025 16:30:33 +0000</pubDate></item><item><title>prim（记录树）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/prim%EF%BC%88-ji-lu-shu-%EF%BC%89.html</link><description>## prim三部曲：

1. 选择距离生成树最近的节点
2. 把最近节点加入生成树
3. 更新非生成树节点到生成树的距离

&gt; 使用一维数组存储最小生成树

## 记录树的细节分析：

* 树的特点是入度为1，所以记录父节点不会出现链接关系被覆盖的情况

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() {
    int n, m, s, e, val;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; graph(n + 1, vector&lt;int&gt;(n + 1, INT_MAX));
    //记录树+
    vector&lt;int&gt; parent(n + 1, -1);
    for(int i = 0; i &lt; m; i++) {
        cin &gt;&gt; s &gt;&gt; e &gt;&gt; val;
        graph[s][e] = val;
        graph[e][s] = val;
    }

    vector&lt;bool&gt; visted(n + 1, false);
    vector&lt;int&gt; miniDist(n + 1, INT_MAX);
    miniDist[1] = 0;

    for(int i = 0; i &lt; n; i++) {
        int cur = 0;
        //寻找最近距离的点
        for(int j = 1; j &lt;= n; j++) {
            if(!visted[j] &amp;&amp; miniDist[j] &lt; miniDist[cur]) {
                cur = j;
            }
        }
        //将该标记为visited
        visted[cur] = true;
        //更新miniDist数组
        for(int j = 1; j &lt;= n; j++) {
            if(!visted[j] &amp;&amp; miniDist[j] &gt; graph[cur][j]) {
                miniDist[j] = graph[cur][j];
                //记录点的连接关系+
                parent[j] = cur;
            }
        }
    }
    //输出 最小生成树
    int res = 0;
    for(int i = 1; i &lt;= n; i++) {
        res += miniDist[i];
    }
    cout &lt;&lt; res &lt;&lt; endl;

    // 输出 最小生成树边的链接情况
    for (int i = 1; i &lt;= v; i++) {
        cout &lt;&lt; i &lt;&lt; '-&gt;' &lt;&lt; parent[i] &lt;&lt; endl;
    }
    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/prim%EF%BC%88-ji-lu-shu-%EF%BC%89.html</guid><pubDate>Tue, 13 May 2025 15:30:16 +0000</pubDate></item><item><title>Bellman_ford</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/Bellman_ford.html</link><description>&gt; 思路特别像prim

## 过程：

* 对`m`条边进行`n - 1`（点数-1）次松弛，更新每个点到原点的最短距离`minDist[to] = min(minDist[to], minDist[start] + val);`
* 理论上，i次松弛使相应节点有距离i条边的最短距离（有也就是说大于i次松弛可能会找到距离边数更多但更短的距离）
## 优化 判断负权回路：

* 如果存在负权回路那么松弛n-1次不会达到最小值，理论可以无限松弛，那么就多松弛一次检查最小值是否会发生变化

## 代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int n, m, s, e, val;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; grid;
    for(int i = 0; i &lt; m; i++) {
        cin &gt;&gt; s &gt;&gt; e &gt;&gt; val;
        grid.push_back({s, e, val});
    }

    vector&lt;int&gt; minDist(n + 1, INT_MAX);
    minDist[1] = 0;
    bool flag = false;//记录是否存在负权回路
    //n - 1次松弛
    for(int i = 0; i &lt; n; i++) {
        //对每一条边进行松弛
        for(int j = 0; j &lt; m; j++) {
            int start = grid[j][0];
            int to = grid[j][1];
            int val = grid[j][2];
            if(i &lt; n - 1) {
                if(minDist[start] != INT_MAX &amp;&amp; minDist[start] + val &lt; minDist[to]) {
                    minDist[to] = minDist[start] + val;
                }
            } else {
                if(minDist[start] != INT_MAX &amp;&amp; minDist[start] + val &lt; minDist[to]) {
                    flag = true;
                }
            }
        }
    }
    if(flag) cout &lt;&lt; 'circle' &lt;&lt; endl;
    else
        minDist[n] == INT_MAX? cout &lt;&lt; 'unconnected' &lt;&lt; endl: cout &lt;&lt; minDist[n] &lt;&lt; endl;

    return 0;
}
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/Bellman_ford.html</guid><pubDate>Tue, 13 May 2025 15:03:59 +0000</pubDate></item><item><title>函数对象（仿函数）以及函数模板与类模板</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/han-shu-dui-xiang-%EF%BC%88-fang-han-shu-%EF%BC%89-yi-ji-han-shu-mo-ban-yu-lei-mo-ban.html</link><description>## 函数模板与类模板

### 一、关键区别：（举例）

#### 1. **`sort`** **是函数模板**

cpp

```cpp
template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );
```

* **lambda 可以隐式转换为函数参数**：
  函数调用时，lambda 会被推导为具体的匿名类型，作为`comp`参数传递给`sort`。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/han-shu-dui-xiang-%EF%BC%88-fang-han-shu-%EF%BC%89-yi-ji-han-shu-mo-ban-yu-lei-mo-ban.html</guid><pubDate>Mon, 12 May 2025 04:10:13 +0000</pubDate></item><item><title>2025/5/11周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-11-zhou-ji.html</link><description>一切都是缘分吗？所谓命运的馈赠。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-11-zhou-ji.html</guid><pubDate>Sun, 11 May 2025 08:17:23 +0000</pubDate></item><item><title>C++的Lambda表达式（隐函数）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/C%2B%2B-de-Lambda-biao-da-shi-%EF%BC%88-yin-han-shu-%EF%BC%89.html</link><description>1. #### 基本结构：

    `[capture](parameters) -&gt; return_type { body }`

    * **`[capture]`** ：捕获列表，用于指定如何捕获外部变量（值捕获、引用捕获等）。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/C%2B%2B-de-Lambda-biao-da-shi-%EF%BC%88-yin-han-shu-%EF%BC%89.html</guid><pubDate>Sat, 10 May 2025 11:26:39 +0000</pubDate></item><item><title>dijkstra（堆优化版）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-dui-you-hua-ban-%EF%BC%89.html</link><description>## 图的表示方式：

1. ### 邻接矩阵

    * #### 优点：

      * 检查任意两个顶点间是否存在边的操作非常快
      * 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-dui-you-hua-ban-%EF%BC%89.html</guid><pubDate>Fri, 09 May 2025 01:26:38 +0000</pubDate></item><item><title>最大子数组和及其构造变式（有趣）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zui-da-zi-shu-zu-he-ji-qi-gou-zao-bian-shi-%EF%BC%88-you-qu-%EF%BC%89.html</link><description>## 复习最大数组和：

1. ### 贪心做法：

    * #### 思路：

      &gt; 遍历的过程中不断维护一个区间和，如果区间和小于零就到达该区间的结束，使和变为0即重新维护一个新的区间，在维护的过程中不断检查区间和的最大值，这样就可以得到最大的那个区间的区间和。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zui-da-zi-shu-zu-he-ji-qi-gou-zao-bian-shi-%EF%BC%88-you-qu-%EF%BC%89.html</guid><pubDate>Thu, 08 May 2025 10:14:34 +0000</pubDate></item><item><title>证伪偶数全排列无法实现ai mod i = i - 1</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zheng-wei-ou-shu-quan-pai-lie-wu-fa-shi-xian-ai%20mod%20i%20%3D%20i%20-%201.html</link><description>## 题目大意：

&gt; 给定1~n个数，要求对其进行重新排列为数组a满足`a[i] % i = i - 1`

## 证明n为偶数不可能有满足条件的数组：

* 设最大的偶数为n，n不能放在`a[n]` `a[1]` `a[2]`处（思路：通过假设试图寻找通式，奇偶性肯定是要讨论的问题，然后通过左右边界来探索问题）
* n只能放在3~n-1处，那么不能放n的位置就要放两个偶数，显然2是偶数，n也是偶数，偶数与偶数的余不可能是奇数，不符合条件。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zheng-wei-ou-shu-quan-pai-lie-wu-fa-shi-xian-ai%20mod%20i%20%3D%20i%20-%201.html</guid><pubDate>Wed, 07 May 2025 08:18:11 +0000</pubDate></item><item><title>一种有趣的答案输出格式化代码</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/yi-zhong-you-qu-de-da-an-shu-chu-ge-shi-hua-dai-ma.html</link><description>## 代码：

```cpp
for(int i = 0; i &lt; n; i++) {
	cout &lt;&lt; '输出内容' &lt;&lt; ' \n'[i == n - 1];
}
```

* 使用了c++的数组（字符串）特性，不是最后一位就用空格隔开，是最后一位就换行。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/yi-zhong-you-qu-de-da-an-shu-chu-ge-shi-hua-dai-ma.html</guid><pubDate>Wed, 07 May 2025 08:03:42 +0000</pubDate></item><item><title>数组最大公约数分组</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-zui-da-gong-yue-shu-fen-zu.html</link><description>## 题目大意：

&gt; 给定一个数组，要求将其分成两组最大公约数不同的子数组，若可以实现，输出“YES”，并输出每一个元素属于第几组，不可以实现只输出“NO”即可

## 解析:

1. 只要最大的数自己一组，最大公约数就是自己（可以从样例中看出）
2. 由1得，只要所有的数不重复就可以满足条件。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-zui-da-gong-yue-shu-fen-zu.html</guid><pubDate>Wed, 07 May 2025 02:18:12 +0000</pubDate></item><item><title>数组博弈</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-bo-yi.html</link><description>## 题目大意：

&gt; n盒子，ai苹果，两人分别取苹果，苹果总数为0没办法再取出当前人就输，如果最大值和最小值差值大于k那么当前人就输（**最后一个取苹果的人**）

## 解析：

* 显然两个足够聪明的人不会使最大值和最小值的差值越界，那么这个约束条件只在开始产生效果，这样就有如下情况：

  1. 刚开始最大值和最小值的差值不满足条件，题目要求输的是最后一个取苹果的人，所以不满足条件第一个人也要去取一个苹果，又有以下情况：

      1. 取一个依然不满足条件，第一个人失败
      2. 取一个满足条件，正常进行后续取出苹果
  2. 正常情况：看总数奇偶性就可以了

## 优化代码：

1. 处理过程中有多个max可以考虑**使用**两次**&lt;u&gt;sort&lt;/u&gt;**，sort也可以代替寻找最大最小值的过程

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int t; cin &gt;&gt; t;
    
    while (t--){
        int n, k; cin &gt;&gt; n &gt;&gt; k;
        
        vector &lt;int&gt; a(n);
        for (auto &amp;x : a) cin &gt;&gt; x;
        
        long long sum = accumulate(a.begin(), a.end(), 0LL);
        
        sort(a.begin(), a.end());
        a[n - 1]--;
        sort(a.begin(), a.end());
        
        if (a[n - 1] - a[0] &gt; k || sum % 2 == 0){
            cout &lt;&lt; 'Jerry\n';
            continue;
        }
        cout &lt;&lt; 'Tom\n';
    }
    return 0;
}
```

## 我的代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
 
void solution() {
    string win[] = {'Tom', 'Jerry'};
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;int&gt; a(n, 0);
    int Max = 0, Min = 1e9 + 5, maxCounts = 0;
    long long sum = 0;

    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
        // Max = max(Max, a[i]);
        if(a[i] &gt; Max) {
            Max = a[i];
            maxCounts = 1;
        } else if(a[i] == Max) maxCounts++;
        Min = min(Min, a[i]);
        sum += a[i];
    }

    if((Max - Min ==  k + 1 &amp;&amp; maxCounts &gt; 1) || Max - Min &gt; k + 1) {
        cout &lt;&lt; win[1] &lt;&lt; endl;
        return;
    }

    //直接通过sum奇偶性判断输家
    if(sum &amp; 1) cout &lt;&lt; win[0] &lt;&lt; endl;
    else cout &lt;&lt; win[1] &lt;&lt; endl;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while(t--) solution();
    return 0;
}

```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-zu-bo-yi.html</guid><pubDate>Tue, 06 May 2025 13:39:11 +0000</pubDate></item><item><title>为使正逆字符的字典序符合条件进行操作</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/wei-shi-zheng-ni-zi-fu-de-zi-dian-xu-fu-he-tiao-jian-jin-xing-cao-zuo.html</link><description>## 问题：

* **定义一种特殊的字符串正序字典序小于逆序字符串的字典序，现在给定一个字符串（长度为n， 只包含小写字符），在给定一个操作次数k，进行如下操作：**

  * 选定i，j两个坐标进行字符反转，如果两者相等就不进行任何操作

  **问：经过k次操作后该字符串能否变成特殊的字符串？**

## 思路：

* ### 进行分类讨论：

  1. 简单的，字符长度为1肯定是“NO”
  2. 给定的字符串有可能直接就是符合条件的特殊字符串
  3. 对给定的字符串进行操作：

      1. 对于非回文字符串，若不符合条件交换正序与逆序第一个不同的字符串就可以符合条件了（😭我眼泪怎么止不住了？）
      2. 对于回文字符串（旨在解决上一个操作无法解决的问题，也就是说先想到了解决方法，然后找到了特解进行修补？不确定），如果不符合条件，就把相邻的两个不同的字符交换就可以了
  4. **综上所述：直接判原字符串是否符合条件秒杀1、2类，检查最大最小值是否相同就秒杀了3类（第三类实质上都是对不同字符的一次操作解决的）**

## 反思：🚩

* 作为一道甚至说是“简单”级别的构造题，我做了很久，至少一个半小时。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/wei-shi-zheng-ni-zi-fu-de-zi-dian-xu-fu-he-tiao-jian-jin-xing-cao-zuo.html</guid><pubDate>Mon, 05 May 2025 13:08:56 +0000</pubDate></item><item><title>循环移位操作下排列中固定点的问题（真的吃力😓）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/xun-huan-yi-wei-cao-zuo-xia-pai-lie-zhong-gu-ding-dian-de-wen-ti-%EF%BC%88-zhen-de-chi-li-%F0%9F%98%93%EF%BC%89.html</link><description>## 模运算：

* ### 定义

  a除以b的余数定义为a mod b

  满足交换律、结合律还有分配律

## 排列与组合

* ### 排列：

  从n个不同元素中取出 m（m &lt;= n）个元素，**&lt;u&gt;按照一定的顺序排成一列&lt;/u&gt;**，叫做从n个不同元素中取出m个元素的一个排列。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/xun-huan-yi-wei-cao-zuo-xia-pai-lie-zhong-gu-ding-dian-de-wen-ti-%EF%BC%88-zhen-de-chi-li-%F0%9F%98%93%EF%BC%89.html</guid><pubDate>Mon, 05 May 2025 09:19:45 +0000</pubDate></item><item><title>再观补码与数据极限</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/zai-guan-bu-ma-yu-shu-ju-ji-xian.html</link><description>## 求补码的方法：

* **正数**：正数的原码、反码和补码都相同，符号位始终为 0 不变。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/zai-guan-bu-ma-yu-shu-ju-ji-xian.html</guid><pubDate>Mon, 05 May 2025 02:06:36 +0000</pubDate></item><item><title>2025/5/4周记</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-4-zhou-ji.html</link><description>周日这天搭建了自己的博客，希望有一天可以自己为博客写一个UI系统，自己的设计也太酷了吧！

**算法**还是有点有基础不牢地动山摇了，我觉得之后要一点一点好好**从基础学起**了

还有**算法题**。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/2025-5-4-zhou-ji.html</guid><pubDate>Sun, 04 May 2025 14:19:16 +0000</pubDate></item><item><title>环状数组（双数组模拟环）（字典序）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/huan-zhuang-shu-zu-%EF%BC%88-shuang-shu-zu-mo-ni-huan-%EF%BC%89%EF%BC%88-zi-dian-xu-%EF%BC%89.html</link><description>![Image](https://github.com/user-attachments/assets/c0cd669f-ab49-4b72-803a-478161e4b9c1)

&gt; 所谓字典序，就是字符串在字典中的顺序。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/huan-zhuang-shu-zu-%EF%BC%88-shuang-shu-zu-mo-ni-huan-%EF%BC%89%EF%BC%88-zi-dian-xu-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 09:16:52 +0000</pubDate></item><item><title>生成元（使用哈希表提高大量数据的处理效率）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/sheng-cheng-yuan-%EF%BC%88-shi-yong-ha-xi-biao-ti-gao-da-liang-shu-ju-de-chu-li-xiao-lv-%EF%BC%89.html</link><description>### 问题：

&gt; x加x的各个数字得到y，就说x是y的生成元。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/sheng-cheng-yuan-%EF%BC%88-shi-yong-ha-xi-biao-ti-gao-da-liang-shu-ju-de-chu-li-xiao-lv-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 08:06:33 +0000</pubDate></item><item><title>输入string转vector</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/shu-ru-string-zhuan-vector.html</link><description>### C++中读取字符串为`vector&lt;char&gt;`的方法：

```cpp
string input;
getline(cin, input); // cin &gt;&gt; input
vector&lt;char&gt; charVector(input.begin(), input.end());
```。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/shu-ru-string-zhuan-vector.html</guid><pubDate>Sun, 04 May 2025 07:32:51 +0000</pubDate></item><item><title>回文与镜像（字符串的灵活使用）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/hui-wen-yu-jing-xiang-%EF%BC%88-zi-fu-chuan-de-ling-huo-shi-yong-%EF%BC%89.html</link><description>![Image](https://github.com/user-attachments/assets/d7cc37ad-718d-4f77-b57a-9d5cc47ae942){style='width:50%;'}

* 镜像可以用一个字符串`rev`表示出来，做镜像就可以直接取字母序号对应的字符来进行替换。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/hui-wen-yu-jing-xiang-%EF%BC%88-zi-fu-chuan-de-ling-huo-shi-yong-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 07:25:36 +0000</pubDate></item><item><title>dijkstra（朴素版）</title><link>https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-pu-su-ban-%EF%BC%89.html</link><description>&gt; `dijkstra`在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</description><guid isPermaLink="true">https://lsh-NJ.github.io/breakMO.github.io/post/dijkstra%EF%BC%88-pu-su-ban-%EF%BC%89.html</guid><pubDate>Sun, 04 May 2025 04:50:57 +0000</pubDate></item></channel></rss>